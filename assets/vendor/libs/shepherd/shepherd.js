(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/shepherd/shepherd.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/*! exports provided: Shepherd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Shepherd\", function() { return shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzPzdhODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiIuL2xpYnMvc2hlcGhlcmQvc2hlcGhlcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2hlcGhlcmQgZnJvbSAnc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZCc7XHJcblxyXG5leHBvcnQgeyBTaGVwaGVyZCB9O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*! shepherd.js 8.3.1 */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx) {\n        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n                handler = binding.handler,\n                once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }]);\n\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n\n\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n\n    return self;\n  }\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref5 = step.options.advanceOn || {},\n        event = _ref5.event,\n        selector = _ref5.selector;\n\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n\n      var el;\n\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n\n    return node;\n  }\n\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  } // and applies them to the HTMLElements such as popper and arrow\n\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n\n  function getBoundingClientRect(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n      width: rect.width,\n      height: rect.height,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      x: rect.left,\n      y: rect.top\n    };\n  } // means it doesn't take into account transforms.\n\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n    return false;\n  }\n\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n\n    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || ( // DOM Element detected\n      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n\n    var currentNode = getParentNode(element);\n\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n\n    return offsetParent || getContainingBlock(element) || window;\n  }\n\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n\n  function arrow(_ref) {\n    var _state$modifiersData$;\n\n    var state = _ref.state,\n        name = _ref.name,\n        options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options;\n    var _options$element = options.element,\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n\n      if (!arrowElement) {\n        return;\n      }\n    }\n\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(round(x * dpr) / dpr) || 0,\n      y: round(round(y * dpr) / dpr) || 0\n    };\n  }\n\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n\n    var popper = _ref2.popper,\n        popperRect = _ref2.popperRect,\n        placement = _ref2.placement,\n        offsets = _ref2.offsets,\n        position = _ref2.position,\n        gpuAcceleration = _ref2.gpuAcceleration,\n        adaptive = _ref2.adaptive,\n        roundOffsets = _ref2.roundOffsets;\n\n    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n        _ref3$x = _ref3.x,\n        x = _ref3$x === void 0 ? 0 : _ref3$x,\n        _ref3$y = _ref3.y,\n        y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n\n        if (getComputedStyle(offsetParent).position !== 'static') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n      offsetParent = offsetParent;\n\n      if (placement === top) {\n        sideY = bottom; // $FlowFixMe[prop-missing]\n\n        y -= offsetParent[heightProp] - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n\n      if (placement === left) {\n        sideX = right; // $FlowFixMe[prop-missing]\n\n        x -= offsetParent[widthProp] - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n\n    if (gpuAcceleration) {\n      var _Object$assign;\n\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n\n  function computeStyles(_ref4) {\n    var state = _ref4.state,\n        options = _ref4.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n        _options$adaptive = options.adaptive,\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n        _options$roundOffsets = options.roundOffsets,\n        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration\n    };\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n\n  function effect(_ref) {\n    var state = _ref.state,\n        instance = _ref.instance,\n        options = _ref.options;\n    var _options$scroll = options.scroll,\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\n        _options$resize = options.resize,\n        resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  } // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n        overflow = _getComputedStyle.overflow,\n        overflowX = _getComputedStyle.overflowX,\n        overflowY = _getComputedStyle.overflowY;\n\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n\n    return getScrollParent(getParentNode(node));\n  }\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n\n    if (list === void 0) {\n      list = [];\n    }\n\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n        element = _ref.element,\n        placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n\n    return offsets;\n  }\n\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$placement = _options.placement,\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\n        _options$boundary = _options.boundary,\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n        _options$rootBoundary = _options.rootBoundary,\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n        _options$elementConte = _options.elementContext,\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n        _options$altBoundary = _options.altBoundary,\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n        _options$padding = _options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var referenceElement = state.elements.reference;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(referenceElement);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n\n    return overflowOffsets;\n  }\n\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        placement = _options.placement,\n        boundary = _options.boundary,\n        rootBoundary = _options.rootBoundary,\n        padding = _options.padding,\n        flipVariations = _options.flipVariations,\n        _options$allowedAutoP = _options.allowedAutoPlacements,\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n\n  function flip(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n        specifiedFallbackPlacements = options.fallbackPlacements,\n        padding = options.padding,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        _options$flipVariatio = options.flipVariations,\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n        allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n\n      var _basePlacement = getBasePlacement(placement);\n\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n\n      checksMap.set(placement, checks);\n    }\n\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n\n        if (_ret === \"break\") break;\n      }\n    }\n\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n\n  function hide(_ref) {\n    var state = _ref.state,\n        name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n      placement: placement\n    })) : offset,\n        skidding = _ref[0],\n        distance = _ref[1];\n\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n\n  function offset(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options,\n        name = _ref2.name;\n    var _options$offset = options.offset,\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n        x = _data$state$placement.x,\n        y = _data$state$placement.y;\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n        name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        padding = options.padding,\n        _options$tether = options.tether,\n        tether = _options$tether === void 0 ? true : _options$tether,\n        _options$tetherOffset = options.tetherOffset,\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var data = {\n      x: 0,\n      y: 0\n    };\n\n    if (!popperOffsets) {\n      return;\n    }\n\n    if (checkMainAxis || checkAltAxis) {\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = popperOffsets[mainAxis] + overflow[mainSide];\n      var max$1 = popperOffsets[mainAxis] - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n      if (checkMainAxis) {\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n      }\n\n      if (checkAltAxis) {\n        var _mainSide = mainAxis === 'x' ? top : left;\n\n        var _altSide = mainAxis === 'x' ? bottom : right;\n\n        var _offset = popperOffsets[altAxis];\n\n        var _min = _offset + overflow[_mainSide];\n\n        var _max = _offset - overflow[_altSide];\n\n        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);\n\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n      }\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  } // Composite means it takes into account transforms as well as layout.\n\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement);\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n\n      return pending;\n    };\n  }\n\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n\n    var _generatorOptions = generatorOptions,\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(options) {\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n\n          var _state$elements = state.elements,\n              reference = _state$elements.reference,\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n\n            var _state$orderedModifie = state.orderedModifiers[index],\n                fn = _state$orderedModifie.fn,\n                _state$orderedModifie2 = _state$orderedModifie.options,\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n                name = _state$orderedModifie.name;\n\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n              _ref3$options = _ref3.options,\n              options = _ref3$options === void 0 ? {} : _ref3$options,\n              effect = _ref3.effect;\n\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n\n            var noopFn = function noopFn() {};\n\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n\n      return instance;\n    };\n  }\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref6) {\n        var state = _ref6.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [{\n        name: 'focusAfterRender',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: function fn() {\n          setTimeout(function () {\n            if (step.el) {\n              step.el.focus();\n            }\n          }, 300);\n        }\n      }]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Checks if options.attachTo.element is a string, and if so, tries to find the element\n   * @param {Step} step The step instance\n   * @returns {{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n\n    if (isString(options.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(options.element);\n      } catch (e) {// TODO\n      }\n\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n\n    return returnOpts;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n\n    var attachToOptions = parseAttachTo(step);\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n\n    if (step.isCentered()) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, {\n        name: 'focusAfterRender',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: function fn() {\n          setTimeout(function () {\n            if (step.el) {\n              step.el.focus();\n            }\n          }, 300);\n        }\n      }],\n      strategy: 'absolute'\n    };\n\n    if (step.isCentered()) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n\n      return mergedPopperOptions;\n    }\n\n    return popperOptions;\n  }\n\n  function noop() {}\n\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n\n    return tar;\n  }\n\n  function run(fn) {\n    return fn();\n  }\n\n  function blank_object() {\n    return Object.create(null);\n  }\n\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n\n  function append(target, node) {\n    target.appendChild(node);\n  }\n\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n\n  function element(name) {\n    return document.createElement(name);\n  }\n\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  function text(data) {\n    return document.createTextNode(data);\n  }\n\n  function space() {\n    return text(' ');\n  }\n\n  function empty() {\n    return text('');\n  }\n\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n\n  var current_component;\n\n  function set_current_component(component) {\n    current_component = component;\n  }\n\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n\n  var flushing = false;\n  var seen_callbacks = new Set();\n\n  function flush() {\n    if (flushing) return;\n    flushing = true;\n\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      for (var i = 0; i < dirty_components.length; i += 1) {\n        var component = dirty_components[i];\n        set_current_component(component);\n        update(component.$$);\n      }\n\n      set_current_component(null);\n      dirty_components.length = 0;\n\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n\n      for (var _i2 = 0; _i2 < render_callbacks.length; _i2 += 1) {\n        var callback = render_callbacks[_i2];\n\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n  }\n\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n\n  var outroing = new Set();\n  var outros;\n\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n\n    outros = outros.p;\n  }\n\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    }\n  }\n\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n\n        for (var _key3 in n) {\n          if (!accounted_for[_key3]) {\n            update[_key3] = n[_key3];\n            accounted_for[_key3] = 1;\n          }\n        }\n\n        levels[i] = n;\n      } else {\n        for (var _key4 in o) {\n          accounted_for[_key4] = 1;\n        }\n      }\n    }\n\n    for (var _key5 in to_null_out) {\n      if (!(_key5 in update)) update[_key5] = undefined;\n    }\n\n    return update;\n  }\n\n  function create_component(block) {\n    block && block.c();\n  }\n\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n        fragment = _component$$$.fragment,\n        on_mount = _component$$$.on_mount,\n        on_destroy = _component$$$.on_destroy,\n        after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n\n        component.$$.on_mount = [];\n      });\n    }\n\n    after_update.forEach(add_render_callback);\n  }\n\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n\n  function init(component, options, instance, create_fragment, not_equal, props) {\n    var dirty = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-1];\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false\n    };\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n\n\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || \"\", \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? \"shepherd-button-secondary\" : \"\"));\n        button.disabled =\n        /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function(\n            /*action*/\n            ctx[0]))\n              /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref7) {\n        var _ref8 = _slicedToArray(_ref7, 1),\n            dirty = _ref8[0];\n\n        ctx = new_ctx;\n        if (dirty &\n        /*text*/\n        32) button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (dirty &\n        /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n\n        if (dirty &\n        /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || \"\", \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? \"shepherd-button-secondary\" : \"\"))) {\n          attr(button, \"class\", button_class_value);\n        }\n\n        if (dirty &\n        /*disabled*/\n        4) {\n          button.disabled =\n          /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n        step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n\n    function getDisabled(disabled) {\n      if (isFunction(disabled)) {\n        return disabled = disabled.call(step);\n      }\n\n      return disabled;\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"config\" in $$props) $$invalidate(6, config = $$props.config);\n      if (\"step\" in $$props) $$invalidate(7, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getDisabled(config.disabled) : false);\n          $$invalidate(3, label = config.label);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text);\n        }\n      }\n    };\n\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n\n    var _super = _createSuper(Shepherd_button);\n\n    function Shepherd_button(options) {\n      var _this3;\n\n      _classCallCheck(this, Shepherd_button);\n\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.37.0 */\n\n\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value =\n    /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n\n    return {\n      c: function c() {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].c();\n        }\n\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {\n          each_blocks[_i4].m(target, anchor);\n        }\n\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty &\n        /*buttons, step*/\n        3) {\n          each_value =\n          /*buttons*/\n          ctx[1];\n\n          var _i5;\n\n          for (_i5 = 0; _i5 < each_value.length; _i5 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i5);\n\n            if (each_blocks[_i5]) {\n              each_blocks[_i5].p(child_ctx, dirty);\n\n              transition_in(each_blocks[_i5], 1);\n            } else {\n              each_blocks[_i5] = create_each_block(child_ctx);\n\n              each_blocks[_i5].c();\n\n              transition_in(each_blocks[_i5], 1);\n\n              each_blocks[_i5].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n\n          group_outros();\n\n          for (_i5 = each_value.length; _i5 < each_blocks.length; _i5 += 1) {\n            out(_i5);\n          }\n\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n\n        for (var _i6 = 0; _i6 < each_value.length; _i6 += 1) {\n          transition_in(each_blocks[_i6]);\n        }\n\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n\n        for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {\n          transition_out(each_blocks[_i7]);\n        }\n\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config:\n        /*config*/\n        ctx[2],\n        step:\n        /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty &\n        /*buttons*/\n        2) shepherdbutton_changes.config =\n        /*config*/\n        ctx[2];\n        if (dirty &\n        /*step*/\n        1) shepherdbutton_changes.step =\n        /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block =\n    /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 1),\n            dirty = _ref10[0];\n\n        if (\n        /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n\n            if (dirty &\n            /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if (\"step\" in $$props) $$invalidate(0, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n\n    return [step, buttons];\n  }\n\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n\n    var _super2 = _createSuper(Shepherd_footer);\n\n    function Shepherd_footer(options) {\n      var _this4;\n\n      _classCallCheck(this, Shepherd_footer);\n\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\");\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n\n        if (!mounted) {\n          dispose = listen(button, \"click\",\n          /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref11) {\n        var _ref12 = _slicedToArray(_ref11, 1),\n            dirty = _ref12[0];\n\n        if (dirty &\n        /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\")) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n        step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n\n    $$self.$$set = function ($$props) {\n      if (\"cancelIcon\" in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [cancelIcon, handleCancelClick, step];\n  }\n\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n\n      _classCallCheck(this, Shepherd_cancel_icon);\n\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\",\n        /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref13) {\n        var _ref14 = _slicedToArray(_ref13, 1),\n            dirty = _ref14[0];\n\n        if (dirty &\n        /*labelId*/\n        2) {\n          attr(h3, \"id\",\n          /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        element = $$props.element,\n        title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"title\" in $$props) $$invalidate(2, title = $$props.title);\n    };\n\n    return [element, labelId, title, h3_binding];\n  }\n\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n\n    var _super4 = _createSuper(Shepherd_title);\n\n    function Shepherd_title(options) {\n      var _this6;\n\n      _classCallCheck(this, Shepherd_title);\n\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[0],\n        title:\n        /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty &\n        /*labelId*/\n        1) shepherdtitle_changes.labelId =\n        /*labelId*/\n        ctx[0];\n        if (dirty &\n        /*title*/\n        4) shepherdtitle_changes.title =\n        /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon:\n        /*cancelIcon*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty &\n        /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon =\n        /*cancelIcon*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        2) shepherdcancelicon_changes.step =\n        /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 =\n    /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 =\n    /*cancelIcon*/\n    ctx[3] &&\n    /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref15) {\n        var _ref16 = _slicedToArray(_ref15, 1),\n            dirty = _ref16[0];\n\n        if (\n        /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (\n        /*cancelIcon*/\n        ctx[3] &&\n        /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        step = $$props.step;\n    var title, cancelIcon;\n\n    $$self.$$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(1, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n\n    return [labelId, step, title, cancelIcon];\n  }\n\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n\n    var _super5 = _createSuper(Shepherd_header);\n\n    function Shepherd_header(options) {\n      var _this7;\n\n      _classCallCheck(this, Shepherd_header);\n\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\",\n        /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref17) {\n        var _ref18 = _slicedToArray(_ref17, 1),\n            dirty = _ref18[0];\n\n        if (dirty &\n        /*descriptionId*/\n        2) {\n          attr(div, \"id\",\n          /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        element = $$props.element,\n        step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [element, descriptionId, step, div_binding];\n  }\n\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n\n    var _super6 = _createSuper(Shepherd_text);\n\n    function Shepherd_text(options) {\n      var _this8;\n\n      _classCallCheck(this, Shepherd_text);\n\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[1],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty &\n        /*labelId*/\n        2) shepherdheader_changes.labelId =\n        /*labelId*/\n        ctx[1];\n        if (dirty &\n        /*step*/\n        4) shepherdheader_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[0],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        1) shepherdtext_changes.descriptionId =\n        /*descriptionId*/\n        ctx[0];\n        if (dirty &\n        /*step*/\n        4) shepherdtext_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty &\n        /*step*/\n        4) shepherdfooter_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined(\n    /*step*/\n    ctx[2].options.title) ||\n    /*step*/\n    ctx[2].options.cancelIcon &&\n    /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined(\n    /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray(\n    /*step*/\n    ctx[2].options.buttons) &&\n    /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref19) {\n        var _ref20 = _slicedToArray(_ref19, 1),\n            dirty = _ref20[0];\n\n        if (dirty &\n        /*step*/\n        4) show_if_2 = !isUndefined(\n        /*step*/\n        ctx[2].options.title) ||\n        /*step*/\n        ctx[2].options.cancelIcon &&\n        /*step*/\n        ctx[2].options.cancelIcon.enabled;\n\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if_1 = !isUndefined(\n        /*step*/\n        ctx[2].options.text);\n\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if = Array.isArray(\n        /*step*/\n        ctx[2].options.buttons) &&\n        /*step*/\n        ctx[2].options.buttons.length;\n\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        labelId = $$props.labelId,\n        step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [descriptionId, labelId, step];\n  }\n\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n\n    var _super7 = _createSuper(Shepherd_content);\n\n    function Shepherd_content(options) {\n      var _this9;\n\n      _classCallCheck(this, Shepherd_content);\n\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block =\n    /*step*/\n    ctx[4].options.arrow &&\n    /*step*/\n    ctx[4].options.attachTo &&\n    /*step*/\n    ctx[4].options.attachTo.element &&\n    /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[2],\n        labelId:\n        /*labelId*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined(\n      /*step*/\n      ctx[4].options.text) ?\n      /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value =\n      /*step*/\n      ctx[4].options.title ?\n      /*labelId*/\n      ctx[3] : null\n    },\n    /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n\n        if (!mounted) {\n          dispose = listen(div, \"keydown\",\n          /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref21) {\n        var _ref22 = _slicedToArray(_ref21, 1),\n            dirty = _ref22[0];\n\n        if (\n        /*step*/\n        ctx[4].options.arrow &&\n        /*step*/\n        ctx[4].options.attachTo &&\n        /*step*/\n        ctx[4].options.attachTo.element &&\n        /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n\n        var shepherdcontent_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId =\n        /*descriptionId*/\n        ctx[2];\n        if (dirty &\n        /*labelId*/\n        8) shepherdcontent_changes.labelId =\n        /*labelId*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        16) shepherdcontent_changes.step =\n        /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty &\n        /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined(\n        /*step*/\n        ctx[4].options.text) ?\n        /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty &\n        /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value =\n        /*step*/\n        ctx[4].options.title ?\n        /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty &\n        /*dataStepId*/\n        2 &&\n        /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n\n  function getClassesArray(classes) {\n    return classes.split(\" \").filter(function (className) {\n      return !!className.length;\n    });\n  }\n\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n        element = $$props.element,\n        descriptionId = $$props.descriptionId,\n        firstFocusableElement = $$props.firstFocusableElement,\n        focusableElements = $$props.focusableElements,\n        labelId = $$props.labelId,\n        lastFocusableElement = $$props.lastFocusableElement,\n        step = $$props.step,\n        dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\\\"0\\\"]\"));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n\n        if (oldClasses.length) {\n          var _element$classList;\n\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n\n        if (newClasses.length) {\n          var _element$classList2;\n\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n          tour = _step.tour;\n\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains(\"shepherd-element\")) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n\n          break;\n\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n\n          break;\n      }\n    };\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"classPrefix\" in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"descriptionId\" in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if (\"firstFocusableElement\" in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if (\"focusableElements\" in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if (\"labelId\" in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if (\"lastFocusableElement\" in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if (\"step\" in $$props) $$invalidate(4, step = $$props.step);\n      if (\"dataStepId\" in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n\n    var _super8 = _createSuper(Shepherd_element);\n\n    function Shepherd_element(options) {\n      var _this10;\n\n      _classCallCheck(this, Shepherd_element);\n\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n\n    return Shepherd_element;\n  }(SvelteComponent);\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n\n            original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n\n    var _super9 = _createSuper(Step);\n\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an attachTo the element will appear in the middle of the screen.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * @param {HTMLElement|string} options.attachTo.element An element selector string or a DOM element.\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour) {\n      var _this11;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Step);\n\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      autoBind(_assertThisInitialized(_this11));\n\n      _this11._setOptions(options);\n\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n\n\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n\n        if (this.el) {\n          this.el.hidden = true;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('hide');\n      }\n      /**\n       * Checks if the step should be centered or not\n       * @return {boolean} True if the step is centered\n       */\n\n    }, {\n      key: \"isCentered\",\n      value: function isCentered() {\n        var attachToOptions = parseAttachTo(this);\n        return !attachToOptions.element || !attachToOptions.on;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _parseAttachTo = parseAttachTo(this),\n            element = _parseAttachTo.element;\n\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions() {\n        var _this13 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n\n        this.el = this._createTooltipContent();\n\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n\n        this.trigger('before-show');\n\n        this._setupElements();\n\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n\n        this.tour.modal.setupForStep(this);\n\n        this._styleTargetElementForStep(this);\n\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n\n        if (!targetElement) {\n          return;\n        }\n\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n\n\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n\n\n  function makeOverlayPath(_ref23) {\n    var width = _ref23.width,\n        height = _ref23.height,\n        _ref23$x = _ref23.x,\n        x = _ref23$x === void 0 ? 0 : _ref23$x,\n        _ref23$y = _ref23.y,\n        y = _ref23$y === void 0 ? 0 : _ref23$y,\n        _ref23$r = _ref23.r,\n        r = _ref23$r === void 0 ? 0 : _ref23$r;\n    var _window = window,\n        w = _window.innerWidth,\n        h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\",\n        /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\", \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\",\n          /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref24) {\n        var _ref25 = _slicedToArray(_ref24, 1),\n            dirty = _ref25[0];\n\n        if (dirty &\n        /*pathDefinition*/\n        4) {\n          attr(path, \"d\",\n          /*pathDefinition*/\n          ctx[2]);\n        }\n\n        if (dirty &\n        /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\", \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== \"hidden\" && overflowY !== \"visible\";\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n        openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n\n    function positionModal() {\n      var modalOverlayOpeningPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var modalOverlayOpeningRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scrollParent = arguments.length > 2 ? arguments[2] : undefined;\n      var targetElement = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n            y = _getVisibleHeight2.y,\n            height = _getVisibleHeight2.height;\n\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n            x = _targetElement$getBou.x,\n            width = _targetElement$getBou.width,\n            _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n\n        show();\n      } else {\n        hide();\n      }\n    }\n\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n\n      window.removeEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n          modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n          modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n\n      rafLoop();\n\n      _addStepEventListeners();\n    }\n\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"openingProperties\" in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n\n    var _super10 = _createSuper(Shepherd_modal);\n\n    function Shepherd_modal(options) {\n      var _this15;\n\n      _classCallCheck(this, Shepherd_modal);\n\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n\n    return Shepherd_modal;\n  }(SvelteComponent);\n\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n\n    var _super11 = _createSuper(Tour);\n\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour() {\n      var _this16;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Tour);\n\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n\n      _this16._setTourID();\n\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n\n\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n\n            step.destroy();\n\n            _this18.steps.splice(i, 1);\n\n            return true;\n          }\n        });\n\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n\n        if (step) {\n          this._updateStateBeforeShow();\n\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n\n        this._setupModal();\n\n        this._setupActiveTour();\n\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n\n        if (this.modal) {\n          this.modal.hide();\n        }\n\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        var nextIndex = forward ? index + 1 : index - 1;\n        this.show(nextIndex, forward);\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n\n    return Tour;\n  }(Evented);\n\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz81YWQxIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvdHlwZS1jaGVjay5qcz8xZmQzIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvZXZlbnRlZC5qcz85NzNkIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvYXV0by1iaW5kLmpzPzdiMTYiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9iaW5kLmpzP2E1MTUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NDY5NyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTA2MCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzPzlhOTQiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/N2NmOCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MTJlYiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzPzE1N2QiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9kZDE0Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzPzc4MDMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzU4MTAiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDkwOCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/MzdkNCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzPzM4NDgiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/ZTA4OSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzU4MmEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzPzVkMGIiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8zYjhjIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9kMDkzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz9kMDdmIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz84MGY1Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz81NDExIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz9kMTMwIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzYzOTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzPzc5MzUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/YTAwNiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz9mODFlIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/OGE3MCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz82NmQzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/ZDdmZSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzPzMzMWUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzc4NjMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9hMzJhIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz82ZjU5Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/OWMzOSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP2QxNmQiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzP2MwMWYiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/NGU3NSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNTM0Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzJlYTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanM/ZGI0OCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz9hYjk3Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/YzM2OSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz81ODAxIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZDhjNyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2Y5OGUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzP2I3ZTYiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/NjZjZiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kZDJhIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2NmYWIiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanM/YjgwYiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDY5Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz9hOTAwIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz81MTVlIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvcG9wcGVyLW9wdGlvbnMuanM/YzY5YiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL3V0aWxzL2dlbmVyYWwuanM/YjQyZCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZT83OGM1Iiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlP2FmNDciLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10aXRsZS5zdmVsdGU/Y2FjMiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZT8yZjI3Iiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZT9mMDdlIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZT9iNTg2Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzP2U2YzgiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9zdGVwLmpzP2FkOGQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9jbGVhbnVwLmpzPzZkY2EiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9vdmVybGF5LXBhdGguanM/Y2Q1MyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlP2Y1NGIiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy90b3VyLmpzPzM5NTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9zaGVwaGVyZC5qcz81MTQ0Il0sIm5hbWVzIjpbImlzTWVyZ2VhYmxlT2JqZWN0IiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwic3RyaW5nVmFsdWUiLCJPYmplY3QiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsInZhbHVlIiwiQXJyYXkiLCJvcHRpb25zIiwiZGVlcG1lcmdlIiwiZW1wdHlUYXJnZXQiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsImN1c3RvbU1lcmdlIiwidGFyZ2V0IiwiZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5IiwiZGVzdGluYXRpb24iLCJnZXRLZXlzIiwicHJvcGVydHlJc1Vuc2FmZSIsInByb3BlcnR5SXNPbk9iamVjdCIsInNvdXJjZSIsImdldE1lcmdlRnVuY3Rpb24iLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJtZXJnZU9iamVjdCIsImRlZXBtZXJnZV8xIiwib24iLCJvbmNlIiwiaXNVbmRlZmluZWQiLCJoYW5kbGVyIiwiY3R4Iiwib2ZmIiwiYmluZGluZyIsInRyaWdnZXIiLCJjb250ZXh0Iiwia2V5cyIsInNlbGYiLCJpIiwia2V5IiwidmFsIiwiZXZlbnQiLCJzdGVwIiwidGFyZ2V0SXNFbCIsInRhcmdldElzU2VsZWN0b3IiLCJzZWxlY3RvciIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJlbCIsImRvY3VtZW50IiwiY29uc29sZSIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZWxlbWVudCIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiT3duRWxlbWVudCIsImdldFdpbmRvdyIsInN0YXRlIiwiX3JlZiIsInN0eWxlIiwiYXR0cmlidXRlcyIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJuYW1lIiwiZW5hYmxlZCIsInBoYXNlIiwiZm4iLCJlZmZlY3QiLCJyZXF1aXJlcyIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwiY2xpZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk1hdGgiLCJyb290Tm9kZSIsImNoaWxkIiwicGFyZW50IiwiaXNTaGFkb3dSb290IiwibmV4dCIsImlzRWxlbWVudCIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsImdldENvbXB1dGVkU3R5bGUiLCJpc0ZpcmVmb3giLCJuYXZpZ2F0b3IiLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImNzcyIsIm9mZnNldFBhcmVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsIm1heCIsIm1pbiIsInJvdW5kIiwibWF0aE1heCIsIm1hdGhNaW4iLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsIm1lcmdlUGFkZGluZ09iamVjdCIsImV4cGFuZFRvSGFzaE1hcCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJiYXNlUGxhY2VtZW50IiwiZ2V0QmFzZVBsYWNlbWVudCIsImF4aXMiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJpc1ZlcnRpY2FsIiwibGVuIiwicGFkZGluZ09iamVjdCIsImFycm93UmVjdCIsImdldExheW91dFJlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsIndpdGhpbiIsImF4aXNQcm9wIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiX29wdGlvbnMkZWxlbWVudCIsImNvbnRhaW5zIiwicmVxdWlyZXNJZkV4aXN0cyIsInVuc2V0U2lkZXMiLCJ3aW4iLCJkcHIiLCJwb3BwZXJSZWN0Iiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiX3JlZjMiLCJyb3VuZE9mZnNldHNCeURQUiIsIl9yZWYzJHgiLCJfcmVmMyR5IiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsImNvbW1vblN0eWxlcyIsIl9PYmplY3QkYXNzaWduIiwiX09iamVjdCRhc3NpZ24yIiwiX3JlZjQiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsIm1hcFRvU3R5bGVzIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJoYXNoIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldFdpbmRvd1Njcm9sbCIsImh0bWwiLCJ2aXN1YWxWaWV3cG9ydCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJ3aW5TY3JvbGwiLCJib2R5IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzU2Nyb2xsUGFyZW50IiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwibGlzdFNjcm9sbFBhcmVudHMiLCJjbGlwcGluZ1BhcmVudCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRWaWV3cG9ydFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldERvY3VtZW50UmVjdCIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiYm91bmRhcnkiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJhY2NSZWN0IiwidmFyaWF0aW9uIiwiZ2V0VmFyaWF0aW9uIiwiY29tbW9uWCIsImNvbW1vblkiLCJtYWluQXhpcyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsInJlZmVyZW5jZUVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJzdHJhdGVneSIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJkZXRlY3RPdmVyZmxvdyIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJmaXR0aW5nUGxhY2VtZW50IiwiX2kiLCJfcmV0IiwiX3NraXAiLCJwcmV2ZW50ZWRPZmZzZXRzIiwicmVmZXJlbmNlT3ZlcmZsb3ciLCJwb3BwZXJBbHRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsImdldFNpZGVPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJkaXN0YW5jZUFuZFNraWRkaW5nVG9YWSIsIl9kYXRhJHN0YXRlJHBsYWNlbWVudCIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsImFsdEF4aXMiLCJnZXRBbHRBeGlzIiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9taW4iLCJfbWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsImdldEhUTUxFbGVtZW50U2Nyb2xsIiwiaXNGaXhlZCIsImRvY3VtZW50RWxlbWVudCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsIm1hcCIsInZpc2l0ZWQiLCJyZXN1bHQiLCJtb2RpZmllcnMiLCJtb2RpZmllciIsImRlcE1vZGlmaWVyIiwic29ydCIsIm9yZGVyZWRNb2RpZmllcnMiLCJvcmRlciIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1lcmdlZCIsImV4aXN0aW5nIiwiY3VycmVudCIsIkRFRkFVTFRfT1BUSU9OUyIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiX2tleSIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJtb2RpZmllcnNEYXRhIiwiZWxlbWVudHMiLCJzdHlsZXMiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm9yZGVyTW9kaWZpZXJzIiwibWVyZ2VCeU5hbWUiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImluZGV4IiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsInVwZGF0ZSIsImRlYm91bmNlIiwiZGVzdHJveSIsIl9yZWYzJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJjcmVhdGVQb3BwZXIiLCJwb3BwZXJHZW5lcmF0b3IiLCJ0cmFuc2Zvcm0iLCJjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyIiwicG9wcGVyT3B0aW9ucyIsInNldFRpbWVvdXQiLCJpc1N0cmluZyIsInByZWZpeCIsInJldHVybk9wdHMiLCJhdHRhY2hUb09wdGlvbnMiLCJwYXJzZUF0dGFjaFRvIiwiZ2V0UG9wcGVyT3B0aW9ucyIsImNvbnRlbnQiLCJkIiwiRGF0ZSIsImMiLCJyIiwibWFrZUNlbnRlcmVkUG9wcGVyIiwiZGVmYXVsdFN0ZXBPcHRpb25zIiwiX21lcmdlTW9kaWZpZXJzIiwic3RlcE9wdGlvbnMiLCJtZXJnZWRQb3BwZXJPcHRpb25zIiwibmFtZXMiLCJtb2QiLCJmaWx0ZXJlZE1vZGlmaWVycyIsInRhciIsInNyYyIsImZucyIsImEiLCJiIiwiYW5jaG9yIiwiaXRlcmF0aW9ucyIsInRleHQiLCJkZXNjcmlwdG9ycyIsImF0dHIiLCJ0b2dnbGUiLCJjdXJyZW50X2NvbXBvbmVudCIsImdldF9jdXJyZW50X2NvbXBvbmVudCIsImRpcnR5X2NvbXBvbmVudHMiLCJiaW5kaW5nX2NhbGxiYWNrcyIsInJlbmRlcl9jYWxsYmFja3MiLCJmbHVzaF9jYWxsYmFja3MiLCJyZXNvbHZlZF9wcm9taXNlIiwidXBkYXRlX3NjaGVkdWxlZCIsImZsdXNoaW5nIiwic2Vlbl9jYWxsYmFja3MiLCJjb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJjYWxsYmFjayIsIiQkIiwicnVuX2FsbCIsImRpcnR5Iiwib3V0cm9pbmciLCJvdXRyb3MiLCJwIiwiYmxvY2siLCJ0b19udWxsX291dCIsImFjY291bnRlZF9mb3IiLCIkJHNjb3BlIiwibGV2ZWxzIiwibyIsIm4iLCJ1cGRhdGVzIiwiYWZ0ZXJfdXBkYXRlIiwiZnJhZ21lbnQiLCJhZGRfcmVuZGVyX2NhbGxiYWNrIiwibmV3X29uX2Rlc3Ryb3kiLCJvbl9tb3VudCIsIm9uX2Rlc3Ryb3kiLCJzY2hlZHVsZV91cGRhdGUiLCJwYXJlbnRfY29tcG9uZW50IiwicHJvcHMiLCJub3RfZXF1YWwiLCJib3VuZCIsImJsYW5rX29iamVjdCIsIm9uX2Rpc2Nvbm5lY3QiLCJiZWZvcmVfdXBkYXRlIiwiY2FsbGJhY2tzIiwic2tpcF9ib3VuZCIsInJlYWR5IiwicmVzdCIsIm1ha2VfZGlydHkiLCJjcmVhdGVfZnJhZ21lbnQiLCJub2RlcyIsImNoaWxkcmVuIiwidHJhbnNpdGlvbl9pbiIsIm1vdW50X2NvbXBvbmVudCIsImZsdXNoIiwiJGRlc3Ryb3kiLCJkZXN0cm95X2NvbXBvbmVudCIsIiRvbiIsIiRzZXQiLCJpc19lbXB0eSIsImNvbmZpZyIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5IiwiZ2V0RGlzYWJsZWQiLCJpc0Z1bmN0aW9uIiwiJCIsImxlbmd0aCIsImJ1dHRvbnMiLCJjYW5jZWxJY29uIiwiaGFuZGxlQ2FuY2VsQ2xpY2siLCJlIiwibGFiZWxJZCIsInRpdGxlIiwiYWZ0ZXJVcGRhdGUiLCJkZXNjcmlwdGlvbklkIiwiS0VZX1RBQiIsIktFWV9FU0MiLCJMRUZUX0FSUk9XIiwiUklHSFRfQVJST1ciLCJnZXRDbGFzc2VzQXJyYXkiLCJjbGFzc05hbWUiLCJjbGFzc1ByZWZpeCIsImZpcnN0Rm9jdXNhYmxlRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwibGFzdEZvY3VzYWJsZUVsZW1lbnQiLCJkYXRhU3RlcElkIiwiaGFzQ2FuY2VsSWNvbiIsImhhc1RpdGxlIiwiZ2V0RWxlbWVudCIsIm9uTW91bnQiLCJpZCIsInVwZGF0ZUR5bmFtaWNDbGFzc2VzIiwicmVtb3ZlQ2xhc3NlcyIsImFkZENsYXNzZXMiLCJvbGRDbGFzc2VzIiwibmV3Q2xhc3NlcyIsImhhbmRsZUtleURvd24iLCJ0b3VyIiwia2V5Q29kZSIsInNoaWZ0S2V5IiwiZXhpdE9uRXNjIiwia2V5Ym9hcmROYXZpZ2F0aW9uIiwidyIsIkVsZW1lbnQiLCJTQ1JPTExfVElNRSIsIm9yaWdpbmFsIiwic2Nyb2xsQnkiLCJlbGVtZW50U2Nyb2xsIiwic2Nyb2xsSW50b1ZpZXciLCJub3ciLCJ1c2VyQWdlbnRQYXR0ZXJucyIsIlJPVU5ESU5HX1RPTEVSQU5DRSIsImlzTWljcm9zb2Z0QnJvd3NlciIsImZpcnN0QXJnIiwib3ZlcmZsb3dWYWx1ZSIsImlzU2Nyb2xsYWJsZVkiLCJoYXNTY3JvbGxhYmxlU3BhY2UiLCJjYW5PdmVyZmxvdyIsImlzU2Nyb2xsYWJsZVgiLCJpc1Njcm9sbGFibGUiLCJ0aW1lIiwiZWxhcHNlZCIsImVhc2UiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwic3RhcnRUaW1lIiwic2Nyb2xsYWJsZSIsInN0YXJ0WCIsInN0YXJ0WSIsIm1ldGhvZCIsInNob3VsZEJhaWxPdXQiLCJzbW9vdGhTY3JvbGwiLCJiZWhhdmlvciIsInNjcm9sbGFibGVQYXJlbnQiLCJmaW5kU2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJtb2R1bGUiLCJwb2x5ZmlsbCIsInNtb290aHNjcm9sbCIsImNvbnN0cnVjdG9yIiwibm9ybWFsaXplUHJlZml4IiwiYXV0b0JpbmQiLCJjYW5jZWwiLCJjb21wbGV0ZSIsImdldFRvdXIiLCJpc0NlbnRlcmVkIiwiaXNPcGVuIiwiQm9vbGVhbiIsInNob3ciLCJiZWZvcmVTaG93UHJvbWlzZSIsInVwZGF0ZVN0ZXBPcHRpb25zIiwiZ2V0VGFyZ2V0IiwiX2NyZWF0ZVRvb2x0aXBDb250ZW50IiwiX3Njcm9sbFRvIiwiX2dldENsYXNzT3B0aW9ucyIsInN0ZXBDbGFzc2VzIiwiZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJ1bmlxQ2xhc3NlcyIsIl9zZXRPcHRpb25zIiwidG91ck9wdGlvbnMiLCJtZXJnZSIsIndoZW4iLCJ1dWlkIiwiX3NldHVwRWxlbWVudHMiLCJiaW5kQWR2YW5jZSIsInNldHVwVG9vbHRpcCIsIl9zaG93IiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJ0YXJnZXRFbGVtZW50IiwiX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUiLCJzdGVwcyIsImlubmVyV2lkdGgiLCJoIiwiaW5uZXJIZWlnaHQiLCJfZ2V0U2Nyb2xsUGFyZW50IiwiaXNIdG1sRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiX2dldFZpc2libGVIZWlnaHQiLCJlbGVtZW50UmVjdCIsInNjcm9sbFJlY3QiLCJzY3JvbGxCb3R0b20iLCJvcGVuaW5nUHJvcGVydGllcyIsIm1vZGFsSXNWaXNpYmxlIiwicmFmSWQiLCJ1bmRlZmluZWQiLCJwYXRoRGVmaW5pdGlvbiIsImNsb3NlTW9kYWxPcGVuaW5nIiwiX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMiLCJwb3NpdGlvbk1vZGFsIiwibW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmciLCJtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIiwic2V0dXBGb3JTdGVwIiwidXNlTW9kYWxPdmVybGF5IiwiX3N0eWxlRm9yU3RlcCIsIl9wcmV2ZW50TW9kYWxCb2R5VG91Y2giLCJfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoIiwiX2FkZFN0ZXBFdmVudExpc3RlbmVycyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmFmTG9vcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1ha2VPdmVybGF5UGF0aCIsIlNoZXBoZXJkIiwiZGVmYXVsdFRvdXJPcHRpb25zIiwiZXZlbnRzIiwib3B0cyIsImFkZFN0ZXAiLCJhZGRTdGVwcyIsImJhY2siLCJjYW5jZWxNZXNzYWdlIiwic3RvcFRvdXIiLCJnZXRCeUlkIiwiZ2V0Q3VycmVudFN0ZXAiLCJjdXJyZW50U3RlcCIsImlzQWN0aXZlIiwicmVtb3ZlU3RlcCIsImZvcndhcmQiLCJzaG91bGRTa2lwU3RlcCIsInByZXZpb3VzIiwiX2RvbmUiLCJjbGVhbnVwU3RlcHMiLCJtb2RhbENvbnRhaW5lciIsIl9zZXR1cEFjdGl2ZVRvdXIiLCJfc2V0dXBNb2RhbCIsIl9za2lwU3RlcCIsIm5leHRJbmRleCIsIl91cGRhdGVTdGF0ZUJlZm9yZVNob3ciLCJfc2V0VG91cklEIiwidG91ck5hbWUiLCJUb3VyIiwiU3RlcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBRUEsSUFBSUEsaUJBQWlCLEdBQUcsa0NBQWtDO0lBQ3pELE9BQU9DLGVBQWUsQ0FBZkEsS0FBZSxDQUFmQSxJQUNILENBQUNDLFNBQVMsQ0FEZCxLQUNjLENBRGQ7RUFERDs7RUFLQSxnQ0FBZ0M7SUFDL0IsT0FBTyxDQUFDLENBQUQsU0FBVyxtQkFBbEI7RUFDQTs7RUFFRCwwQkFBMEI7SUFDekIsSUFBSUMsV0FBVyxHQUFHQyxNQUFNLENBQU5BLHdCQUFsQixLQUFrQkEsQ0FBbEI7SUFFQSxPQUFPRCxXQUFXLEtBQVhBLHFCQUNIQSxXQUFXLEtBRFJBLG1CQUVIRSxjQUFjLENBRmxCLEtBRWtCLENBRmxCO0VBR0EsQyxDQUFBOzs7RUFHRCxJQUFJQyxZQUFZLEdBQUcs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O0FBQ0Y7QUFDQTtBQUNBOzs7O2FBQ0VDLHNCQUFhO1FBQ1gsSUFBTUMsUUFBUSxHQUFHLHlCQUFqQjtRQUVBLG9CQUFhQSxRQUFiLGVBQTBCbEUsSUFBMUI7TUFDRDs7OztJQTlWSSxPOztFQ1hQcGxCLE1BQU0sQ0FBTkEsaUJBQXdCO0lBQUV1cEIsSUFBRixFQUFFQSxJQUFGO0lBQVFDO0VBQVIsQ0FBeEJ4cEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBIVE1MRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBIVE1MRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2snO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRlZCB7XG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIG9uY2UgPSBmYWxzZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlciwgY3R4LCBvbmNlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcbiAgfVxuXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSB8fFxuICAgICAgaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudCwgLi4uYXJncykge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLmZvckVhY2goKGJpbmRpbmcsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBoYW5kbGVyLCBvbmNlIH0gPSBiaW5kaW5nO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjdHggfHwgdGhpcztcblxuICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0iLCIvKipcbiAqIEJpbmRzIGFsbCB0aGUgbWV0aG9kcyBvbiBhIEpTIENsYXNzIHRvIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3MuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hdXRvLWJpbmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWxmIFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvQmluZChzZWxmKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsID0gc2VsZltrZXldO1xuICAgIGlmIChrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZltrZXldID0gdmFsLmJpbmQoc2VsZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4iLCJpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4vdHlwZS1jaGVjayc7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgaGFuZGxlciB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGFkdmFuY2UgdGhlIHRvdXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zZXR1cEFkdmFuY2VPbkhhbmRsZXIoc2VsZWN0b3IsIHN0ZXApIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICBjb25zdCB0YXJnZXRJc0VsID0gc3RlcC5lbCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBzdGVwLmVsO1xuICAgICAgY29uc3QgdGFyZ2V0SXNTZWxlY3RvciA9ICFpc1VuZGVmaW5lZChzZWxlY3RvcikgJiYgZXZlbnQuY3VycmVudFRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKTtcblxuICAgICAgaWYgKHRhcmdldElzU2VsZWN0b3IgfHwgdGFyZ2V0SXNFbCkge1xuICAgICAgICBzdGVwLnRvdXIubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kIHRoZSBldmVudCBoYW5kbGVyIGZvciBhZHZhbmNlT25cbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFkdmFuY2Uoc3RlcCkge1xuICAvLyBBbiBlbXB0eSBzZWxlY3RvciBtYXRjaGVzIHRoZSBzdGVwIGVsZW1lbnRcbiAgY29uc3QgeyBldmVudCwgc2VsZWN0b3IgfSA9IHN0ZXAub3B0aW9ucy5hZHZhbmNlT24gfHwge307XG4gIGlmIChldmVudCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKTtcblxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGFsc28gYmluZC91bmJpbmQgb24gc2hvdy9oaWRlXG4gICAgbGV0IGVsO1xuICAgIHRyeSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChzZWxlY3RvcikgJiYgIWVsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgTm8gZWxlbWVudCB3YXMgZm91bmQgZm9yIHRoZSBzZWxlY3RvciBzdXBwbGllZCB0byBhZHZhbmNlT246ICR7c2VsZWN0b3J9YCk7XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIHN0ZXAub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdhZHZhbmNlT24gd2FzIGRlZmluZWQsIGJ1dCBubyBldmVudCBuYW1lIHdhcyBwYXNzZWQuJyk7XG4gIH1cbn1cbiIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB4OiByZWN0LmxlZnQsXG4gICAgeTogcmVjdC50b3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHJvdW5kKHggKiBkcHIpIC8gZHByKSB8fCAwLFxuICAgIHk6IHJvdW5kKHJvdW5kKHkgKiBkcHIpIC8gZHByKSB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHM7XG5cbiAgdmFyIF9yZWYzID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIob2Zmc2V0cykgOiB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKG9mZnNldHMpIDogb2Zmc2V0cyxcbiAgICAgIF9yZWYzJHggPSBfcmVmMy54LFxuICAgICAgeCA9IF9yZWYzJHggPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR4LFxuICAgICAgX3JlZjMkeSA9IF9yZWYzLnksXG4gICAgICB5ID0gX3JlZjMkeSA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHk7XG5cbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3ApIHtcbiAgICAgIHNpZGVZID0gYm90dG9tOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgeSAtPSBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF0gLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB4IC09IG9mZnNldFBhcmVudFt3aWR0aFByb3BdIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDwgMiA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNC5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb25cbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZUVsZW1lbnQpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMgfHwgY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKF9taW4sIHRldGhlck1pbikgOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KF9tYXgsIHRldGhlck1heCkgOiBfbWF4KTtcblxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50KTtcbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCJmdW5jdGlvbiBfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICBmbih7IHN0YXRlIH0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gJ3BvcHBlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSdcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhcnJheSBvZiBvcHRpb25zIGZvciBhIHRvb2x0aXAgdGhhdCBkb2Vzbid0IGhhdmUgYVxuICogdGFyZ2V0IGVsZW1lbnQgaW4gdGhlIERPTSAtLSBhbmQgdGh1cyBpcyBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqIG9mIHRoZSB2aWV3XG4gKlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaW5hbCBQb3BwZXIgb3B0aW9ucyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDZW50ZXJlZFBvcHBlcihzdGVwKSB7XG4gIGNvbnN0IGNlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllciA9IF9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIoKTtcblxuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHN0cmF0ZWd5OiAnZml4ZWQnLFxuICAgIG1vZGlmaWVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnZm9jdXNBZnRlclJlbmRlcicsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICAgIGZuKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZXAuZWwpIHtcbiAgICAgICAgICAgICAgc3RlcC5lbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICAuLi5wb3BwZXJPcHRpb25zLFxuICAgIG1vZGlmaWVyczogQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQoWy4uLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLCAuLi5jZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXJdKVxuICAgIClcbiAgfTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcbmltcG9ydCB7IG1ha2VDZW50ZXJlZFBvcHBlciB9IGZyb20gJy4vcG9wcGVyLW9wdGlvbnMnO1xuXG4vKipcbiAqIEVuc3VyZSBjbGFzcyBwcmVmaXggZW5kcyBpbiBgLWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBwcmVwZW5kIHRvIHRoZSBjbGFzcyBuYW1lcyBnZW5lcmF0ZWQgYnkgbmFuby1jc3NcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHByZWZpeCBlbmRpbmcgaW4gYC1gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQcmVmaXgocHJlZml4KSB7XG4gIGlmICghaXNTdHJpbmcocHJlZml4KSB8fCBwcmVmaXggPT09ICcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeC5jaGFyQXQocHJlZml4Lmxlbmd0aCAtIDEpICE9PSAnLScgPyBgJHtwcmVmaXh9LWAgOiBwcmVmaXg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIG9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCBpcyBhIHN0cmluZywgYW5kIGlmIHNvLCB0cmllcyB0byBmaW5kIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHt7ZWxlbWVudCwgb259fVxuICogYGVsZW1lbnRgIGlzIGEgcXVhbGlmaWVkIEhUTUwgRWxlbWVudFxuICogYG9uYCBpcyBhIHN0cmluZyBwb3NpdGlvbiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRhY2hUbyhzdGVwKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gfHwge307XG4gIGNvbnN0IHJldHVybk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5lbGVtZW50KSkge1xuICAgIC8vIENhbid0IG92ZXJyaWRlIHRoZSBlbGVtZW50IGluIHVzZXIgb3B0cyByZWZlcmVuY2UgYmVjYXVzZSB3ZSBjYW4ndFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBlbGVtZW50IHdpbGwgZXhpc3QgaW4gdGhlIGZ1dHVyZS5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuT3B0cy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgaWYgKCFyZXR1cm5PcHRzLmVsZW1lbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBUaGUgZWxlbWVudCBmb3IgdGhpcyBTaGVwaGVyZCBzdGVwIHdhcyBub3QgZm91bmQgJHtvcHRpb25zLmVsZW1lbnR9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuT3B0cztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG9wdGlvbnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpbml0aWFsaXplc1xuICogYHN0ZXAudG9vbHRpcGAgYXMgYSBQb3BwZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwVG9vbHRpcChzdGVwKSB7XG4gIGlmIChzdGVwLnRvb2x0aXApIHtcbiAgICBzdGVwLnRvb2x0aXAuZGVzdHJveSgpO1xuICB9XG5cbiAgY29uc3QgYXR0YWNoVG9PcHRpb25zID0gcGFyc2VBdHRhY2hUbyhzdGVwKTtcblxuICBsZXQgdGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG4gIGNvbnN0IHBvcHBlck9wdGlvbnMgPSBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCk7XG5cbiAgaWYgKHN0ZXAuaXNDZW50ZXJlZCgpKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBjb250ZW50ID0gc3RlcC5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtY2VudGVyZWQnKTtcbiAgfVxuXG4gIHN0ZXAudG9vbHRpcCA9IGNyZWF0ZVBvcHBlcih0YXJnZXQsIHN0ZXAuZWwsIHBvcHBlck9wdGlvbnMpO1xuICBzdGVwLnRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHVuaXF1ZSBpZCBmb3Igc3RlcHMsIHRvdXJzLCBtb2RhbHMsIGV0Y1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgbGV0IGQgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgIGNvbnN0IHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgUG9wcGVyYCBvcHRpb25zIGZyb20gYSBzZXQgb2YgYmFzZSBgYXR0YWNoVG9gIG9wdGlvbnNcbiAqIEBwYXJhbSBhdHRhY2hUb09wdGlvbnNcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvcHBlck9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKSB7XG4gIGxldCBwb3BwZXJPcHRpb25zID0ge1xuICAgIG1vZGlmaWVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFsdEF4aXM6IHRydWUsXG4gICAgICAgICAgdGV0aGVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZm9jdXNBZnRlclJlbmRlcicsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICAgIGZuKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZXAuZWwpIHtcbiAgICAgICAgICAgICAgc3RlcC5lbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG4gIH07XG5cbiAgaWYgKHN0ZXAuaXNDZW50ZXJlZCgpKSB7XG4gICAgcG9wcGVyT3B0aW9ucyA9IG1ha2VDZW50ZXJlZFBvcHBlcihzdGVwKTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPcHRpb25zLnBsYWNlbWVudCA9IGF0dGFjaFRvT3B0aW9ucy5vbjtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9ucyA9XG4gICAgc3RlcC50b3VyICYmIHN0ZXAudG91ci5vcHRpb25zICYmIHN0ZXAudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICBpZiAoZGVmYXVsdFN0ZXBPcHRpb25zKSB7XG4gICAgcG9wcGVyT3B0aW9ucyA9IF9tZXJnZU1vZGlmaWVycyhkZWZhdWx0U3RlcE9wdGlvbnMsIHBvcHBlck9wdGlvbnMpO1xuICB9XG5cbiAgcG9wcGVyT3B0aW9ucyA9IF9tZXJnZU1vZGlmaWVycyhzdGVwLm9wdGlvbnMsIHBvcHBlck9wdGlvbnMpO1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBfbWVyZ2VNb2RpZmllcnMoc3RlcE9wdGlvbnMsIHBvcHBlck9wdGlvbnMpIHtcbiAgaWYgKHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMpIHtcbiAgICBsZXQgbWVyZ2VkUG9wcGVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHBvcHBlck9wdGlvbnMsXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzICYmXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLm1hcCgobW9kKSA9PiBtb2QubmFtZSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZE1vZGlmaWVycyA9IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLmZpbHRlcihcbiAgICAgICAgKG1vZCkgPT4gIW5hbWVzLmluY2x1ZGVzKG1vZC5uYW1lKVxuICAgICAgKTtcblxuICAgICAgbWVyZ2VkUG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgPSBBcnJheS5mcm9tKFxuICAgICAgICBuZXcgU2V0KFsuLi5maWx0ZXJlZE1vZGlmaWVycywgLi4uc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnNdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkUG9wcGVyT3B0aW9ucztcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuIiwiZnVuY3Rpb24gbm9vcCgpIHsgfVxuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgdGFyW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiB0YXI7XG59XG5mdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3Qoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90X3NwcmVhZChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X3NwcmVhZF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3Rfc3ByZWFkX2NoYW5nZXNfZm4oZGlydHkpIHwgZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSA9IHJldCkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqKytdO1xuICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVtb3ZlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocmVtb3ZlW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN2ZyA/IHN2Z19lbGVtZW50KG5hbWUpIDogZWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQoZGF0YSk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYSA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBhY3RpdmVfZG9jcyA9IG5ldyBTZXQoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGFjdGl2ZV9kb2NzLmFkZChkb2MpO1xuICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldCB8fCAoZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgPSBkb2MuaGVhZC5hcHBlbmRDaGlsZChlbGVtZW50KCdzdHlsZScpKS5zaGVldCk7XG4gICAgY29uc3QgY3VycmVudF9ydWxlcyA9IGRvYy5fX3N2ZWx0ZV9ydWxlcyB8fCAoZG9jLl9fc3ZlbHRlX3J1bGVzID0ge30pO1xuICAgIGlmICghY3VycmVudF9ydWxlc1tuYW1lXSkge1xuICAgICAgICBjdXJyZW50X3J1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhY3RpdmVfZG9jcy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQ7XG4gICAgICAgICAgICBsZXQgaSA9IHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gICAgICAgICAgICBkb2MuX19zdmVsdGVfcnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZV9kb2NzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbihldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxubGV0IGZsdXNoaW5nID0gZmFsc2U7XG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGlmIChmbHVzaGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gcHJvZ3JhbS5iIC0gdDtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyDigJQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyDigJQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuXG5jb25zdCBnbG9iYWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiBnbG9iYWwpO1xuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgY2xhc3Nlc190b19hZGQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uYXJncyk7XG4gICAgaWYgKGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICBlbHNlIGlmIChib29sZWFuX2F0dHJpYnV0ZXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1wiL2csICcmIzM0OycpLnJlcGxhY2UoLycvZywgJyYjMzk7Jyl9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IGVzY2FwZWQgPSB7XG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnXG59O1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcbiAgICByZXR1cm4gU3RyaW5nKGh0bWwpLnJlcGxhY2UoL1tcIicmPD5dL2csIG1hdGNoID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBjb250ZXh0IHx8IFtdKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHJldHVybiBgICR7bmFtZX0ke3ZhbHVlID09PSB0cnVlID8gJycgOiBgPSR7dHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KGVzY2FwZSh2YWx1ZSkpIDogYFwiJHt2YWx1ZX1cImB9YH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBvbl9tb3VudCwgb25fZGVzdHJveSwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogb3B0aW9ucy5jb250ZXh0IHx8IFtdKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZVxuICAgIH07XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50cm8pXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvciwgb3B0aW9ucy5jdXN0b21FbGVtZW50KTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuMzcuMCcgfSwgZGV0YWlsKSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgY29uc3QgZGlzcG9zZSA9IGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuICAgIGVsc2VcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGFzZXQnLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBlcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVDb21wb25lbnRUeXBlZCwgU3ZlbHRlRWxlbWVudCwgYWN0aW9uX2Rlc3Ryb3llciwgYWRkX2F0dHJpYnV0ZSwgYWRkX2NsYXNzZXMsIGFkZF9mbHVzaF9jYWxsYmFjaywgYWRkX2xvY2F0aW9uLCBhZGRfcmVuZGVyX2NhbGxiYWNrLCBhZGRfcmVzaXplX2xpc3RlbmVyLCBhZGRfdHJhbnNmb3JtLCBhZnRlclVwZGF0ZSwgYXBwZW5kLCBhcHBlbmRfZGV2LCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9zcGFjZSwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlc2NhcGUsIGVzY2FwZWQsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0Q29udGV4dCwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dCwgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBpZGVudGl0eSwgaW5pdCwgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3Rfc3ByZWFkLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB4bGlua19hdHRyIH07XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBjb25maWcsIHN0ZXA7XG4gIGxldCBhY3Rpb24sIGNsYXNzZXMsIGRpc2FibGVkLCBsYWJlbCwgc2Vjb25kYXJ5LCB0ZXh0O1xuXG4gICQ6IHtcbiAgICBhY3Rpb24gPSBjb25maWcuYWN0aW9uID8gY29uZmlnLmFjdGlvbi5iaW5kKHN0ZXAudG91cikgOiBudWxsO1xuICAgIGNsYXNzZXMgPSBjb25maWcuY2xhc3NlcztcbiAgICBkaXNhYmxlZCA9IGNvbmZpZy5kaXNhYmxlZCA/IGdldERpc2FibGVkKGNvbmZpZy5kaXNhYmxlZCkgOiBmYWxzZTtcbiAgICBsYWJlbCA9IGNvbmZpZy5sYWJlbDtcbiAgICBzZWNvbmRhcnkgPSBjb25maWcuc2Vjb25kYXJ5O1xuICAgIHRleHQgPSBjb25maWcudGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihkaXNhYmxlZCkpIHtcbiAgICAgICAgICByZXR1cm4gZGlzYWJsZWQgPSBkaXNhYmxlZC5jYWxsKHN0ZXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc2FibGVkXG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1idXR0b24ge1xuICAgIGJhY2tncm91bmQ6IHJnYig1MCwgMTM2LCAyMzApO1xuICAgIGJvcmRlcjogMDtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xuICAgIHBhZGRpbmc6IDAuNXJlbSAxLjVyZW07XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNSwgMTExLCAyMDQpO1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjQxLCAyNDIsIDI0Myk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnk6bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyMTQsIDIxNywgMjE5KTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246ZGlzYWJsZWQge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntsYWJlbCA/IGxhYmVsIDogbnVsbH1cIlxuICBjbGFzcz1cIntgJHsoY2xhc3NlcyB8fCAnJyl9IHNoZXBoZXJkLWJ1dHRvbiAkeyhzZWNvbmRhcnkgPyAnc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeScgOiAnJyl9YH1cIlxuICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gIG9uOmNsaWNrPXthY3Rpb259XG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAge0BodG1sIHRleHR9XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEJ1dHRvbiBmcm9tICcuL3NoZXBoZXJkLWJ1dHRvbi5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgc3RlcDtcblxuICAkOiBidXR0b25zID0gc3RlcC5vcHRpb25zLmJ1dHRvbnM7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWZvb3RlciB7XG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIHBhZGRpbmc6IDAgMC43NXJlbSAwLjc1cmVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLWZvb3RlciAuc2hlcGhlcmQtYnV0dG9uOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGZvb3RlciBjbGFzcz1cInNoZXBoZXJkLWZvb3RlclwiPlxuICAgIHsjaWYgYnV0dG9uc31cbiAgICAgICAgeyNlYWNoIGJ1dHRvbnMgYXMgY29uZmlnfVxuICAgICAgICAgIDxTaGVwaGVyZEJ1dHRvblxuICAgICAgICAgICAge2NvbmZpZ31cbiAgICAgICAgICAgIHtzdGVwfVxuICAgICAgICAgIC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuPC9mb290ZXI+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGNhbmNlbEljb24sIHN0ZXA7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBjYW5jZWwgbGluayB0aGF0IGNhbmNlbHMgdGhlIHRvdXJcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbmNlbENsaWNrID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3RlcC5jYW5jZWwoKTtcbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICB0cmFuc2l0aW9uOiBjb2xvciAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7Y2FuY2VsSWNvbi5sYWJlbCA/IGNhbmNlbEljb24ubGFiZWwgOiAnQ2xvc2UgVG91cid9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC1jYW5jZWwtaWNvblwiXG4gIG9uOmNsaWNrPXtoYW5kbGVDYW5jZWxDbGlja31cbiAgdHlwZT1cImJ1dHRvblwiXG4+XG4gIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuICBcbiAgZXhwb3J0IGxldCBsYWJlbElkLCBlbGVtZW50LCB0aXRsZTtcbiAgXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aXRsZSkpIHtcbiAgICAgIHRpdGxlID0gdGl0bGUoKTtcbiAgICB9XG4gICAgXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRpdGxlIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIGZsZXg6IDEgMCBhdXRvO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48aDNcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBpZD1cIntsYWJlbElkfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtdGl0bGVcIlxuPlxuPC9oMz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZENhbmNlbEljb24gZnJvbSAnLi9zaGVwaGVyZC1jYW5jZWwtaWNvbi5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUaXRsZSBmcm9tICcuL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBsYWJlbElkLCBzdGVwO1xuICBsZXQgdGl0bGUsIGNhbmNlbEljb247XG5cbiAgJDoge1xuICAgICAgdGl0bGUgPSBzdGVwLm9wdGlvbnMudGl0bGU7XG4gICAgICBjYW5jZWxJY29uID0gc3RlcC5vcHRpb25zLmNhbmNlbEljb247XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBsaW5lLWhlaWdodDogMmVtO1xuICAgIHBhZGRpbmc6IDAuNzVyZW0gMC43NXJlbSAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBiYWNrZ3JvdW5kOiAjZTZlNmU2O1xuICAgIHBhZGRpbmc6IDFlbTtcbiAgfVxuPC9zdHlsZT5cblxuPGhlYWRlciBjbGFzcz1cInNoZXBoZXJkLWhlYWRlclwiPlxuICAgIHsjaWYgdGl0bGV9XG4gICAgICA8U2hlcGhlcmRUaXRsZVxuICAgICAgICB7bGFiZWxJZH1cbiAgICAgICAge3RpdGxlfVxuICAgICAgLz5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBjYW5jZWxJY29uICYmIGNhbmNlbEljb24uZW5hYmxlZH1cbiAgICAgIDxTaGVwaGVyZENhbmNlbEljb25cbiAgICAgICAge2NhbmNlbEljb259XG4gICAgICAgIHtzdGVwfVxuICAgICAgLz5cbiAgICB7L2lmfVxuPC9oZWFkZXI+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGVsZW1lbnQsIHN0ZXA7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGxldCB7IHRleHQgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5jYWxsKHN0ZXApO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRleHQpKSB7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGV4dCB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGxpbmUtaGVpZ2h0OiAxLjNlbTtcbiAgICBwYWRkaW5nOiAwLjc1ZW07XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcDpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9XCJzaGVwaGVyZC10ZXh0XCJcbiAgaWQ9XCJ7ZGVzY3JpcHRpb25JZH1cIlxuPlxuPC9kaXY+XG5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEZvb3RlciBmcm9tICcuL3NoZXBoZXJkLWZvb3Rlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRIZWFkZXIgZnJvbSAnLi9zaGVwaGVyZC1oZWFkZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGV4dCBmcm9tICcuL3NoZXBoZXJkLXRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGxhYmVsSWQsIHN0ZXA7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNvbnRlbnQge1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgY2xhc3M9XCJzaGVwaGVyZC1jb250ZW50XCJcbj5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRpdGxlKSB8fCAoc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCl9XG4gICAgPFNoZXBoZXJkSGVhZGVyXG4gICAgICB7bGFiZWxJZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpfVxuICAgIDxTaGVwaGVyZFRleHRcbiAgICAgIHtkZXNjcmlwdGlvbklkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmIEFycmF5LmlzQXJyYXkoc3RlcC5vcHRpb25zLmJ1dHRvbnMpICYmIHN0ZXAub3B0aW9ucy5idXR0b25zLmxlbmd0aH1cbiAgICA8U2hlcGhlcmRGb290ZXJcbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQsIGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkQ29udGVudCBmcm9tICcuL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgY29uc3QgS0VZX1RBQiA9IDk7XG4gIGNvbnN0IEtFWV9FU0MgPSAyNztcbiAgY29uc3QgTEVGVF9BUlJPVyA9IDM3O1xuICBjb25zdCBSSUdIVF9BUlJPVyA9IDM5O1xuXG4gIGV4cG9ydCBsZXQgY2xhc3NQcmVmaXgsIGVsZW1lbnQsIGRlc2NyaXB0aW9uSWQsIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCxcbiAgICBmb2N1c2FibGVFbGVtZW50cywgbGFiZWxJZCwgbGFzdEZvY3VzYWJsZUVsZW1lbnQsIHN0ZXAsIGRhdGFTdGVwSWQ7XG5cbiAgbGV0IGhhc0NhbmNlbEljb24sIGhhc1RpdGxlLCBjbGFzc2VzO1xuXG4gICQ6IHtcbiAgICBoYXNDYW5jZWxJY29uID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQ7XG4gICAgaGFzVGl0bGUgPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLnRpdGxlO1xuICB9XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIC8vIEdldCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZm9jdXNhYmxlXG4gICAgZGF0YVN0ZXBJZCA9IHsgW2BkYXRhLSR7Y2xhc3NQcmVmaXh9c2hlcGhlcmQtc3RlcC1pZGBdOiBzdGVwLmlkIH07XG4gICAgZm9jdXNhYmxlRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgZmlyc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmKGNsYXNzZXMgIT09IHN0ZXAub3B0aW9ucy5jbGFzc2VzKSB7XG4gICAgICB1cGRhdGVEeW5hbWljQ2xhc3NlcygpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRHluYW1pY0NsYXNzZXMoKSB7XG4gICAgICByZW1vdmVDbGFzc2VzKGNsYXNzZXMpO1xuICAgICAgY2xhc3NlcyA9IHN0ZXAub3B0aW9ucy5jbGFzc2VzO1xuICAgICAgYWRkQ2xhc3NlcyhjbGFzc2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmIChpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChvbGRDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAobmV3Q2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzZXNBcnJheShjbGFzc2VzKSB7XG4gICAgIHJldHVybiBjbGFzc2VzLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiAhIWNsYXNzTmFtZS5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGtleWRvd24gZXZlbnRzIHRvIGFsbG93IGNsb3NpbmcgdGhlIG1vZGFsIHdpdGggRVNDXG4gICAqXG4gICAqIEJvcnJvd2VkIGZyb20gdGhpcyBncmVhdCBwb3N0ISBodHRwczovL2JpdHNvZmNvLmRlL2FjY2Vzc2libGUtbW9kYWwtZGlhbG9nL1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlKSA9PiB7XG4gICAgY29uc3QgeyB0b3VyIH0gPSBzdGVwO1xuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtFWV9UQUI6XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmQgdGFiXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZpcnN0Rm9jdXNhYmxlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hlcGhlcmQtZWxlbWVudCcpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0VTQzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5leGl0T25Fc2MpIHtcbiAgICAgICAgICBzdGVwLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHRvdXIuYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MsIHZpc2liaWxpdHkgMC4zcztcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgei1pbmRleDogOTk5OTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5dOm5vdCguc2hlcGhlcmQtY2VudGVyZWQpIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LCAuc2hlcGhlcmQtZWxlbWVudCAqLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmFmdGVyLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmJlZm9yZSB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdyxcbiAgLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTZweDtcbiAgICBoZWlnaHQ6IDE2cHg7XG4gICAgei1pbmRleDogLTE7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3c6YmVmb3JlIHtcbiAgICBjb250ZW50OiAnJztcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG4gICAgYmFja2dyb3VuZDogI2ZmZiAgO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ndG9wJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGJvdHRvbTogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICB0b3A6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdsZWZ0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHJpZ2h0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ncmlnaHQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgbGVmdDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWNlbnRlcmVkID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG5cblxuICAvKipcbiAgKiBBcnJvdyBvbiB0b3Agb2YgdG9vbHRpcCBjZW50ZXJlZCBob3Jpem9udGFsbHksIHdpdGggdGl0bGUgY29sb3JcbiAgKi9cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtaGFzLXRpdGxlW2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XG4gIH1cblxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0LFxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0ICoge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGFyaWEtZGVzY3JpYmVkYnk9eyFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCkgPyBkZXNjcmlwdGlvbklkIDogbnVsbH1cbiAgYXJpYS1sYWJlbGxlZGJ5PXtzdGVwLm9wdGlvbnMudGl0bGUgPyBsYWJlbElkIDogbnVsbH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzczpzaGVwaGVyZC1oYXMtY2FuY2VsLWljb249XCJ7aGFzQ2FuY2VsSWNvbn1cIlxuICBjbGFzczpzaGVwaGVyZC1oYXMtdGl0bGU9XCJ7aGFzVGl0bGV9XCJcbiAgY2xhc3M6c2hlcGhlcmQtZWxlbWVudD1cInt0cnVlfVwiXG4gIHsuLi5kYXRhU3RlcElkfVxuICBvbjprZXlkb3duPXtoYW5kbGVLZXlEb3dufVxuICByb2xlPVwiZGlhbG9nXCJcbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7I2lmIHN0ZXAub3B0aW9ucy5hcnJvdyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLm9ufVxuICAgICAgPGRpdiBjbGFzcz1cInNoZXBoZXJkLWFycm93XCIgZGF0YS1wb3BwZXItYXJyb3c+PC9kaXY+XG4gICAgey9pZn1cbiAgPFNoZXBoZXJkQ29udGVudFxuICAgIHtkZXNjcmlwdGlvbklkfVxuICAgIHtsYWJlbElkfVxuICAgIHtzdGVwfVxuICAvPlxuPC9kaXY+XG4iLCIvKiBzbW9vdGhzY3JvbGwgdjAuNC40IC0gMjAxOSAtIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIGFsaWFzZXNcbiAgICB2YXIgdyA9IHdpbmRvdztcbiAgICB2YXIgZCA9IGRvY3VtZW50O1xuXG4gICAgLy8gcmV0dXJuIGlmIHNjcm9sbCBiZWhhdmlvciBpcyBzdXBwb3J0ZWQgYW5kIHBvbHlmaWxsIGlzIG5vdCBmb3JjZWRcbiAgICBpZiAoXG4gICAgICAnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmXG4gICAgICB3Ll9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsc1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLy8gb2JqZWN0IGdhdGhlcmluZyBvcmlnaW5hbCBzY3JvbGwgbWV0aG9kc1xuICAgIHZhciBvcmlnaW5hbCA9IHtcbiAgICAgIHNjcm9sbDogdy5zY3JvbGwgfHwgdy5zY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5OiB3LnNjcm9sbEJ5LFxuICAgICAgZWxlbWVudFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIHRpbWluZyBtZXRob2RcbiAgICB2YXIgbm93ID1cbiAgICAgIHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgICAgPyB3LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHcucGVyZm9ybWFuY2UpXG4gICAgICAgIDogRGF0ZS5ub3c7XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSB0aGUgY3VycmVudCBicm93c2VyIGlzIG1hZGUgYnkgTWljcm9zb2Z0XG4gICAgICogQG1ldGhvZCBpc01pY3Jvc29mdEJyb3dzZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNaWNyb3NvZnRCcm93c2VyKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVzZXJBZ2VudFBhdHRlcm5zID0gWydNU0lFICcsICdUcmlkZW50LycsICdFZGdlLyddO1xuXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1c2VyQWdlbnRQYXR0ZXJucy5qb2luKCd8JykpLnRlc3QodXNlckFnZW50KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElFIGhhcyByb3VuZGluZyBidWcgcm91bmRpbmcgZG93biBjbGllbnRIZWlnaHQgYW5kIGNsaWVudFdpZHRoIGFuZFxuICAgICAqIHJvdW5kaW5nIHVwIHNjcm9sbEhlaWdodCBhbmQgc2Nyb2xsV2lkdGggY2F1c2luZyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgKiBvbiBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKi9cbiAgICB2YXIgUk9VTkRJTkdfVE9MRVJBTkNFID0gaXNNaWNyb3NvZnRCcm93c2VyKHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAxIDogMDtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBmaXJzdEFyZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoZmlyc3RBcmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZmlyc3RBcmcgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGZpcnN0QXJnICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnYXV0bycgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdpbnN0YW50J1xuICAgICAgKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QvbnVsbFxuICAgICAgICAvLyBvciBiZWhhdmlvciBpcyBhdXRvLCBpbnN0YW50IG9yIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcgJiYgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnYmVoYXZpb3IgbWVtYmVyIG9mIFNjcm9sbE9wdGlvbnMgJyArXG4gICAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgK1xuICAgICAgICAgICcgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVudW1lcmF0aW9uIFNjcm9sbEJlaGF2aW9yLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgc3BhY2UgaW4gdGhlIHByb3ZpZGVkIGF4aXNcbiAgICAgKiBAbWV0aG9kIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbGFibGVTcGFjZShlbCwgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT09ICdZJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50SGVpZ2h0ICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyA9PT0gJ1gnKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRXaWR0aCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBhIHNjcm9sbGFibGUgb3ZlcmZsb3cgcHJvcGVydHkgaW4gdGhlIGF4aXNcbiAgICAgKiBAbWV0aG9kIGNhbk92ZXJmbG93XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuT3ZlcmZsb3coZWwsIGF4aXMpIHtcbiAgICAgIHZhciBvdmVyZmxvd1ZhbHVlID0gdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKVsnb3ZlcmZsb3cnICsgYXhpc107XG5cbiAgICAgIHJldHVybiBvdmVyZmxvd1ZhbHVlID09PSAnYXV0bycgfHwgb3ZlcmZsb3dWYWx1ZSA9PT0gJ3Njcm9sbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgY2FuIGJlIHNjcm9sbGVkIGluIGVpdGhlciBheGlzXG4gICAgICogQG1ldGhvZCBpc1Njcm9sbGFibGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwpIHtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVZID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWScpICYmIGNhbk92ZXJmbG93KGVsLCAnWScpO1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVggPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdYJykgJiYgY2FuT3ZlcmZsb3coZWwsICdYJyk7XG5cbiAgICAgIHJldHVybiBpc1Njcm9sbGFibGVZIHx8IGlzU2Nyb2xsYWJsZVg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHdoaWxlIChlbCAhPT0gZC5ib2R5ICYmIGlzU2Nyb2xsYWJsZShlbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZSB8fCBlbC5ob3N0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IG9yIGVsZW1lbnQgd2l0aCBhIHNtb290aCBiZWhhdmlvclxuICAgICAqIEBtZXRob2Qgc21vb3RoU2Nyb2xsXG4gICAgICogQHBhcmFtIHtPYmplY3R8Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT1JJR0lOQUwgTUVUSE9EUyBPVkVSUklERVNcbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgaWYgcHJlc2VudCBvciBmYWxsYmFjayB0byBzY3JvbGxZXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gYXJndW1lbnRzWzBdIDogMCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDBcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIG9uZSBudW1iZXIgaXMgcGFzc2VkLCB0aHJvdyBlcnJvciB0byBtYXRjaCBGaXJlZm94IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLy8gdXNlIGxlZnQgcHJvcCwgZmlyc3QgbnVtYmVyIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbExlZnRcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyB+fmFyZ3VtZW50c1swXSA6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxUb3BcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gfn5hcmd1bWVudHNbMV0gOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBhcmd1bWVudHNbMF0ubGVmdDtcbiAgICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMF0udG9wO1xuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxMZWZ0IDogfn5sZWZ0LFxuICAgICAgICB0eXBlb2YgdG9wID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsVG9wIDogfn50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1swXSArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMV0gKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICBsZWZ0OiB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICBiZWhhdmlvcjogYXJndW1lbnRzWzBdLmJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0IHVubGVzcyBpcyBmaXhlZFxuICAgICAgICBpZiAody5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG5cbn0oKSk7XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgYmluZEFkdmFuY2UgfSBmcm9tICcuL3V0aWxzL2JpbmQuanMnO1xuaW1wb3J0IHtcbiAgc2V0dXBUb29sdGlwLFxuICBwYXJzZUF0dGFjaFRvLFxuICBub3JtYWxpemVQcmVmaXgsXG4gIHV1aWRcbn0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZEVsZW1lbnQgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlJztcblxuLy8gUG9seWZpbGxzXG5pbXBvcnQgc21vb3Roc2Nyb2xsIGZyb20gJ3Ntb290aHNjcm9sbC1wb2x5ZmlsbCc7XG5zbW9vdGhzY3JvbGwucG9seWZpbGwoKTtcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBzdGVwcyB0byBiZSBhZGRlZCB0byBhIHRvdXIuXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZXAgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0ZXBcbiAgICogQHBhcmFtIHtUb3VyfSB0b3VyIFRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFycm93IFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgYXJyb3cgZm9yIHRoZSB0b29sdGlwIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5hdHRhY2hUbyBUaGUgZWxlbWVudCB0aGUgc3RlcCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gb24gdGhlIHBhZ2UuXG4gICAqIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYGVsZW1lbnRgIGFuZCBgb25gLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGF0dGFjaFRvOiB7IGVsZW1lbnQ6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIG9uOiAnbGVmdCcgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSBkb27igJl0IHNwZWNpZnkgYW4gYXR0YWNoVG8gdGhlIGVsZW1lbnQgd2lsbCBhcHBlYXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLlxuICAgKiBJZiB5b3Ugb21pdCB0aGUgYG9uYCBwb3J0aW9uIG9mIGBhdHRhY2hUb2AsIHRoZSBlbGVtZW50IHdpbGwgc3RpbGwgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGUgdG9vbHRpcCB3aWxsIGFwcGVhclxuICAgKiBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4sIHdpdGhvdXQgYW4gYXJyb3cgcG9pbnRpbmcgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxzdHJpbmd9IG9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCBBbiBlbGVtZW50IHNlbGVjdG9yIHN0cmluZyBvciBhIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hdHRhY2hUby5vbiBUaGUgb3B0aW9uYWwgZGlyZWN0aW9uIHRvIHBsYWNlIHRoZSBQb3BwZXIgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudC5cbiAgICogICAtIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXM6ICdhdXRvJywgJ2F1dG8tc3RhcnQnLCAnYXV0by1lbmQnLCAndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdyaWdodCcsICdyaWdodC1zdGFydCcsICdyaWdodC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hZHZhbmNlT24gQW4gYWN0aW9uIG9uIHRoZSBwYWdlIHdoaWNoIHNob3VsZCBhZHZhbmNlIHNoZXBoZXJkIHRvIHRoZSBuZXh0IHN0ZXAuXG4gICAqIEl0IHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBhIHN0cmluZyBgc2VsZWN0b3JgIGFuZCBhbiBgZXZlbnRgIG5hbWVcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhZHZhbmNlT246IHsgc2VsZWN0b3I6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIGV2ZW50OiAnY2xpY2snIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgZXZlbnRgIGRvZXNu4oCZdCBoYXZlIHRvIGJlIGFuIGV2ZW50IGluc2lkZSB0aGUgdG91ciwgaXQgY2FuIGJlIGFueSBldmVudCBmaXJlZCBvbiBhbnkgZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAgICogWW91IGNhbiBhbHNvIGFsd2F5cyBtYW51YWxseSBhZHZhbmNlIHRoZSBUb3VyIGJ5IGNhbGxpbmcgYG15VG91ci5uZXh0KClgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJlZm9yZVNob3dQcm9taXNlIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICogV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIHJlc3Qgb2YgdGhlIGBzaG93YCBjb2RlIGZvciB0aGUgc3RlcCB3aWxsIGV4ZWN1dGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMuYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIHRvIGFkZCB0byB0aGUgc3RlcC4gVGhlc2Ugd2lsbCBiZSByZW5kZXJlZCBpbiBhXG4gICAqIGZvb3RlciBiZWxvdyB0aGUgbWFpbiBib2R5IHRleHQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uYWN0aW9uIEEgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgb24uXG4gICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gdGhlIGB0b3VyYCB0aGUgc3RlcCBpcyBhc3NvY2lhdGVkIHdpdGgsIHNvIHRoaW5ncyBsaWtlIGB0aGlzLm5leHRgIHdpbGxcbiAgICogd29yayBpbnNpZGUgdGhlIGFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgYWN0aW9uIHRvIHNraXAgc3RlcHMgb3IgbmF2aWdhdGUgdG8gc3BlY2lmaWMgc3RlcHMsIHdpdGggc29tZXRoaW5nIGxpa2U6XG4gICAqIGBgYGpzXG4gICAqIGFjdGlvbigpIHtcbiAgICogICByZXR1cm4gdGhpcy5zaG93KCdzb21lX3N0ZXBfbmFtZScpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5jbGFzc2VzIEV4dHJhIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGA8YT5gXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5kaXNhYmxlZCBTaG91bGQgdGhlIGJ1dHRvbiBiZSBkaXNhYmxlZD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24ubGFiZWwgVGhlIGFyaWEtbGFiZWwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5zZWNvbmRhcnkgSWYgdHJ1ZSwgYSBzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IGNsYXNzIGlzIGFwcGxpZWQgdG8gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi50ZXh0IFRoZSBIVE1MIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgQSBib29sZWFuLCB0aGF0IHdoZW4gc2V0IHRvIGZhbHNlLCB3aWxsIHNldCBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSB0YXJnZXRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2FuY2VsSWNvbiBPcHRpb25zIGZvciB0aGUgY2FuY2VsIGljb25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCBTaG91bGQgYSBjYW5jZWwg4oCc4pyV4oCdIGJlIHNob3duIGluIHRoZSBoZWFkZXIgb2YgdGhlIHN0ZXA/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhbmNlbEljb24ubGFiZWwgVGhlIGxhYmVsIHRvIGFkZCBmb3IgYGFyaWEtbGFiZWxgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsYXNzZXMgQSBzdHJpbmcgb2YgZXh0cmEgY2xhc3NlcyB0byBhZGQgdG8gdGhlIHN0ZXAncyBjb250ZW50IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmhpZ2hsaWdodENsYXNzIEFuIGV4dHJhIGNsYXNzIHRvIGFwcGx5IHRvIHRoZSBgYXR0YWNoVG9gIGVsZW1lbnQgd2hlbiBpdCBpc1xuICAgKiBoaWdobGlnaHRlZCAodGhhdCBpcywgd2hlbiBpdHMgc3RlcCBpcyBhY3RpdmUpLiBZb3UgY2FuIHRoZW4gdGFyZ2V0IHRoYXQgc2VsZWN0b3IgaW4geW91ciBDU1MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmlkIFRoZSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBgaWRgIGZvciB0aGUgc3RlcC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgQW4gYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnBvcHBlck9wdGlvbnMgRXh0cmEgb3B0aW9ucyB0byBwYXNzIHRvIFBvcHBlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBvcHRpb25zLnNjcm9sbFRvIFNob3VsZCB0aGUgZWxlbWVudCBiZSBzY3JvbGxlZCB0byB3aGVuIHRoaXMgc3RlcCBpcyBzaG93bj8gSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBge2JlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInfWBcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IGxldHMgeW91IG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbFRvIGJlaGF2aW9yIGFuZFxuICAgKiBkZWZpbmUgYSBjdXN0b20gYWN0aW9uIHRvIGRvIHRoZSBzY3JvbGxpbmcsIGFuZCBwb3NzaWJseSBvdGhlciBsb2dpYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zaG93T24gQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGl0IHJldHVybnMgYHRydWVgLCB3aWxsIHNob3cgdGhlIHN0ZXAuXG4gICAqIElmIGl0IHJldHVybnMgZmFsc2UsIHRoZSBzdGVwIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgdGV4dCBpbiB0aGUgYm9keSBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0aHJlZSB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgSFRNTEVsZW1lbnRgIG9iamVjdFxuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gb25lIHRoZSB0d28gb3B0aW9ucyBhYm92ZS5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSBzdGVwJ3MgdGl0bGUuIEl0IGJlY29tZXMgYW4gYGgzYCBhdCB0aGUgdG9wIG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHR3byB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIEhUTUwgc3RyaW5nLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMud2hlbiBZb3UgY2FuIGRlZmluZSBgc2hvd2AsIGBoaWRlYCwgZXRjIGV2ZW50cyBpbnNpZGUgYHdoZW5gLiBGb3IgZXhhbXBsZTpcbiAgICogYGBganNcbiAgICogd2hlbjoge1xuICAgKiAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGNyZWF0ZWQgU3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IodG91ciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodG91ciwgb3B0aW9ucyk7XG4gICAgdGhpcy50b3VyID0gdG91cjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gdGhpcy50b3VyLm9wdGlvbnNcbiAgICAgID8gbm9ybWFsaXplUHJlZml4KHRoaXMudG91ci5vcHRpb25zLmNsYXNzUHJlZml4KVxuICAgICAgOiAnJztcbiAgICB0aGlzLnN0eWxlcyA9IHRvdXIuc3R5bGVzO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY2FuY2VsYCBldmVudFxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMudG91ci5jYW5jZWwoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnRvdXIuY29tcGxldGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzdGVwLCBkZWxldGUgdGhlIHN0ZXAncyBlbGVtZW50LCBhbmQgZGVzdHJveSB0aGUgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgc3RlcC5cbiAgICogVHJpZ2dlcnMgYGRlc3Ryb3lgIGV2ZW50XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZWwpICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7VG91cn0gVGhlIHRvdXIgaW5zdGFuY2VcbiAgICovXG4gIGdldFRvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudG91cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMudG91ci5tb2RhbC5oaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1oaWRlJyk7XG5cbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5oaWRkZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignaGlkZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3RlcCBzaG91bGQgYmUgY2VudGVyZWQgb3Igbm90XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0ZXAgaXMgY2VudGVyZWRcbiAgICovXG4gIGlzQ2VudGVyZWQoKSB7XG4gICAgY29uc3QgYXR0YWNoVG9PcHRpb25zID0gcGFyc2VBdHRhY2hUbyh0aGlzKTtcbiAgICByZXR1cm4gIWF0dGFjaFRvT3B0aW9ucy5lbGVtZW50IHx8ICFhdHRhY2hUb09wdGlvbnMub247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmVsICYmICF0aGlzLmVsLmhpZGRlbik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYF9zaG93YCBhbmQgZW5zdXJlcyBgYmVmb3JlU2hvd1Byb21pc2VgIHJlc29sdmVzIGJlZm9yZSBjYWxsaW5nIHNob3dcbiAgICogQHJldHVybiB7KnxQcm9taXNlfVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICBjb25zdCBiZWZvcmVTaG93UHJvbWlzZSA9IHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSgpO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZChiZWZvcmVTaG93UHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIGJlZm9yZVNob3dQcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG9wdGlvbnMgb2YgdGhlIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKi9cbiAgdXBkYXRlU3RlcE9wdGlvbnMob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuJHNldCh7IHN0ZXA6IHRoaXMgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIGl0IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIHF1ZXJ5IHN0cmluZyBoYXMgbm90IGJlZW4gZm91bmRcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBTaGVwaGVyZCBlbGVtZW50IGZvciBzdGVwIGJhc2VkIG9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIERPTSBlbGVtZW50IGZvciB0aGUgc3RlcCB0b29sdGlwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVG9vbHRpcENvbnRlbnQoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb25JZCA9IGAke3RoaXMuaWR9LWRlc2NyaXB0aW9uYDtcbiAgICBjb25zdCBsYWJlbElkID0gYCR7dGhpcy5pZH0tbGFiZWxgO1xuXG4gICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQgPSBuZXcgU2hlcGhlcmRFbGVtZW50KHtcbiAgICAgIHRhcmdldDogdGhpcy50b3VyLm9wdGlvbnMuc3RlcHNDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBkZXNjcmlwdGlvbklkLFxuICAgICAgICBsYWJlbElkLFxuICAgICAgICBzdGVwOiB0aGlzLFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgY3VzdG9tIHNjcm9sbFRvSGFuZGxlciBpcyBkZWZpbmVkLCBjYWxsIHRoYXQsIG90aGVyd2lzZSBkbyB0aGUgZ2VuZXJpY1xuICAgKiBzY3JvbGxJbnRvVmlldyBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBzY3JvbGxUb09wdGlvbnMgSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBgeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJyB9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Njcm9sbFRvKHNjcm9sbFRvT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gcGFyc2VBdHRhY2hUbyh0aGlzKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0VsZW1lbnQoZWxlbWVudCkgJiZcbiAgICAgIHR5cGVvZiBlbGVtZW50LnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHNjcm9sbFRvT3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIF9nZXRDbGFzc09wdGlvbnMgZ2V0cyBhbGwgcG9zc2libGUgY2xhc3NlcyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0ZXBPcHRpb25zIFRoZSBzdGVwIHNwZWNpZmljIG9wdGlvbnNcbiAgICogQHJldHVybnMge1N0cmluZ30gdW5pcXVlIHN0cmluZyBmcm9tIGFycmF5IG9mIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDbGFzc09wdGlvbnMoc3RlcE9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcbiAgICBjb25zdCBzdGVwQ2xhc3NlcyA9IHN0ZXBPcHRpb25zLmNsYXNzZXMgPyBzdGVwT3B0aW9ucy5jbGFzc2VzIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyA9XG4gICAgICBkZWZhdWx0U3RlcE9wdGlvbnMgJiYgZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgPyBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBbXG4gICAgICAuLi5zdGVwQ2xhc3Nlcy5zcGxpdCgnICcpLFxuICAgICAgLi4uZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3Nlcy5zcGxpdCgnICcpXG4gICAgXTtcbiAgICBjb25zdCB1bmlxQ2xhc3NlcyA9IG5ldyBTZXQoYWxsQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxQ2xhc3Nlcykuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgc3RlcCwgbWFwcyBgd2hlbmAgdG8gZXZlbnRzLCBzZXRzIHVwIGJ1dHRvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdG91ck9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICAgIHRvdXJPcHRpb25zID0gbWVyZ2Uoe30sIHRvdXJPcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGFycm93OiB0cnVlXG4gICAgICB9LFxuICAgICAgdG91ck9wdGlvbnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGNvbnN0IHsgd2hlbiB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5vcHRpb25zLmNsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkIHx8IGBzdGVwLSR7dXVpZCgpfWA7XG5cbiAgICBpZiAod2hlbikge1xuICAgICAgT2JqZWN0LmtleXMod2hlbikuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5vbihldmVudCwgd2hlbltldmVudF0sIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZWxlbWVudCBhbmQgc2V0IHVwIHRoZSBQb3BwZXIgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEVsZW1lbnRzKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5lbCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSB0aGlzLl9jcmVhdGVUb29sdGlwQ29udGVudCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZHZhbmNlT24pIHtcbiAgICAgIGJpbmRBZHZhbmNlKHRoaXMpO1xuICAgIH1cbiAgICBzZXR1cFRvb2x0aXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYGJlZm9yZS1zaG93YCwgZ2VuZXJhdGVzIHRoZSB0b29sdGlwIERPTSBjb250ZW50LFxuICAgKiBzZXRzIHVwIGEgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgdG9vbHRpcCwgdGhlbiB0cmlnZ2VycyBgc2hvd2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvdygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1zaG93Jyk7XG5cbiAgICB0aGlzLl9zZXR1cEVsZW1lbnRzKCk7XG5cbiAgICBpZiAoIXRoaXMudG91ci5tb2RhbCkge1xuICAgICAgdGhpcy50b3VyLl9zZXR1cE1vZGFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy50b3VyLm1vZGFsLnNldHVwRm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLl9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvLyBzdGFydCBzY3JvbGxpbmcgdG8gdGFyZ2V0IGJlZm9yZSBzaG93aW5nIHRoZSBzdGVwXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUbykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMub3B0aW9ucy5zY3JvbGxUbyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGApO1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1lbmFibGVkJyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGF0ZXMgdGhlIHN0eWxlcyBvZiB0aGUgcGFzc2VkIHN0ZXAncyB0YXJnZXQgZWxlbWVudCwgYmFzZWQgb24gdGhlIHN0ZXAncyBvcHRpb25zIGFuZFxuICAgKiB0aGUgdG91cidzIGBtb2RhbGAgb3B0aW9uLCB0byB2aXN1YWxseSBlbXBoYXNpemUgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXAgVGhlIHN0ZXAgb2JqZWN0IHRoYXQgYXR0YWNoZXMgdG8gdGhlIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gc3RlcC50YXJnZXQ7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHN0ZXAgaXMgaGlkZGVuLCByZW1vdmUgdGhlIGhpZ2hsaWdodENsYXNzIGFuZCAnc2hlcGhlcmQtZW5hYmxlZCdcbiAgICogYW5kICdzaGVwaGVyZC10YXJnZXQnIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpO1xuICAgIH1cblxuICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcsXG4gICAgICBgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC10YXJnZXRgXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDbGVhbnVwIHRoZSBzdGVwcyBhbmQgc2V0IHBvaW50ZXJFdmVudHMgYmFjayB0byAnYXV0bydcbiAqIEBwYXJhbSB0b3VyIFRoZSB0b3VyIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cFN0ZXBzKHRvdXIpIHtcbiAgaWYgKHRvdXIpIHtcbiAgICBjb25zdCB7IHN0ZXBzIH0gPSB0b3VyO1xuXG4gICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgaWYgKHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgPT09IGZhbHNlICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUbykge1xuICAgICAgICBpZiAoc3RlcC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIHN0ZXAudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogR2VuZXJhdGVzIHRoZSBzdmcgcGF0aCBkYXRhIGZvciBhIHJvdW5kZWQgcmVjdGFuZ2xlIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb24gLSBEaW1lbnNpb25zIG9mIHJlY3RhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB4IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB5IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wXSAtIENvcm5lciBSYWRpdXMuIEtlZXAgdGhpcyBzbWFsbGVyIHRoYW4gIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0LlxuICogQHJldHVybnMge3N0cmluZ30gLSBSb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5IHBhdGggZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPdmVybGF5UGF0aCh7IHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCwgciA9IDAgfSkge1xuICBjb25zdCB7IGlubmVyV2lkdGg6IHcsIGlubmVySGVpZ2h0OiBoIH0gPSB3aW5kb3c7XG5cbiAgcmV0dXJuIGBNJHt3fSwke2h9XFxcbkgwXFxcblYwXFxcbkgke3d9XFxcblYke2h9XFxcblpcXFxuTSR7eCArIHJ9LCR7eX1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LCR7cn1cXFxuViR7aGVpZ2h0ICsgeSAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfSwke3J9XFxcbkgke3dpZHRoICsgeCAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfS0ke3J9XFxcblYke3kgKyByfVxcXG5hJHtyfSwke3J9LDAsMCwwLSR7cn0tJHtyfVxcXG5aYDtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHV1aWQgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsLmpzJztcbiAgaW1wb3J0IHsgbWFrZU92ZXJsYXlQYXRoIH0gZnJvbSAnLi4vdXRpbHMvb3ZlcmxheS1wYXRoLmpzJztcblxuICBleHBvcnQgbGV0IGVsZW1lbnQsIG9wZW5pbmdQcm9wZXJ0aWVzO1xuICBjb25zdCBndWlkID0gdXVpZCgpO1xuICBsZXQgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcbiAgbGV0IHJhZklkID0gdW5kZWZpbmVkO1xuICBsZXQgcGF0aERlZmluaXRpb247XG5cbiAgJDogcGF0aERlZmluaXRpb24gPSBtYWtlT3ZlcmxheVBhdGgob3BlbmluZ1Byb3BlcnRpZXMpO1xuXG4gIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBjbG9zZU1vZGFsT3BlbmluZygpIHtcbiAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGNsZWFudXAgYWxsIGV2ZW50IGxpc3RlbmVycyB3aGVuIHdlIGhpZGUgdGhlIG1vZGFsXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQgd2Ugd2FudCB0aGUgb3BlbmluZyBvdmVydG9wIG9mIHRvIHNldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb3BlbmluZyBhbmQgcG9zaXRpb24gaXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2Nyb2xsUGFyZW50IFRoZSBzY3JvbGxhYmxlIHBhcmVudCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0aGUgb3BlbmluZyB3aWxsIGV4cG9zZVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uTW9kYWwoXG4gICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgPSAwLFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgPSAwLFxuICAgIHNjcm9sbFBhcmVudCxcbiAgICB0YXJnZXRFbGVtZW50XG4gICkge1xuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICBjb25zdCB7IHksIGhlaWdodCB9ID0gX2dldFZpc2libGVIZWlnaHQodGFyZ2V0RWxlbWVudCwgc2Nyb2xsUGFyZW50KTtcbiAgICAgIGNvbnN0IHsgeCwgd2lkdGgsIGxlZnQgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBub3QgY29uc2lzdGVudC4gU29tZSBicm93c2VycyB1c2UgeCBhbmQgeSwgd2hpbGUgb3RoZXJzIHVzZSBsZWZ0IGFuZCB0b3BcbiAgICAgIG9wZW5pbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGggKyBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyAqIDIsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICB4OiAoeCB8fCBsZWZ0KSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICB5OiB5IC0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIHI6IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG1vZGFsIGlzIGVuYWJsZWQsIHNldHVwIHRoZSBzdmcgbWFzayBvcGVuaW5nIGFuZCBtb2RhbCBvdmVybGF5IGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXR1cEZvclN0ZXAoc3RlcCkge1xuICAgIC8vIEVuc3VyZSB3ZSBtb3ZlIGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLCBiZWZvcmUgd2Ugc2V0dXAgbmV3IG9uZXNcbiAgICBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHN0ZXAudG91ci5vcHRpb25zLnVzZU1vZGFsT3ZlcmxheSkge1xuICAgICAgX3N0eWxlRm9yU3RlcChzdGVwKTtcbiAgICAgIHNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2hvdygpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBfcHJldmVudE1vZGFsQm9keVRvdWNoID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICAvLyBQcmV2ZW50cyB3aW5kb3cgZnJvbSBtb3Zpbmcgb24gdG91Y2guXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCBhbmQgcmVtb3ZlIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmIChyYWZJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgcmFmSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGUgdGhlIG1vZGFsIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc3R5bGUgdGhlIG9wZW5pbmcgZm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc3R5bGVGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gX2dldFNjcm9sbFBhcmVudChzdGVwLnRhcmdldCk7XG5cbiAgICAvLyBTZXR1cCByZWN1cnNpdmUgZnVuY3Rpb24gdG8gY2FsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdXBkYXRlIHRoZSBtb2RhbCBvcGVuaW5nIHBvc2l0aW9uXG4gICAgY29uc3QgcmFmTG9vcCA9ICgpID0+IHtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgICAgcG9zaXRpb25Nb2RhbChcbiAgICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMsXG4gICAgICAgIHNjcm9sbFBhcmVudCxcbiAgICAgICAgc3RlcC50YXJnZXRcbiAgICAgICk7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZMb29wKTtcbiAgICB9O1xuXG4gICAgcmFmTG9vcCgpO1xuXG4gICAgX2FkZFN0ZXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSHRtbEVsZW1lbnQgPSBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgY29uc3Qgb3ZlcmZsb3dZID1cbiAgICAgIGlzSHRtbEVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkub3ZlcmZsb3dZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IG92ZXJmbG93WSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3dZICE9PSAndmlzaWJsZSc7XG5cbiAgICBpZiAoaXNTY3JvbGxhYmxlICYmIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID49IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldFNjcm9sbFBhcmVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlzaWJsZSBoZWlnaHQgb2YgdGhlIHRhcmdldCBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBzY3JvbGxQYXJlbnQuXG4gICAqIElmIHRoZXJlIGlzIG5vIHNjcm9sbCBwYXJlbnQsIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtzY3JvbGxQYXJlbnRdIFRoZSBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHt7eTogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VmlzaWJsZUhlaWdodChlbGVtZW50LCBzY3JvbGxQYXJlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHRvcCA9IGVsZW1lbnRSZWN0LnkgfHwgZWxlbWVudFJlY3QudG9wO1xuICAgIGxldCBib3R0b20gPSBlbGVtZW50UmVjdC5ib3R0b20gfHwgdG9wICsgZWxlbWVudFJlY3QuaGVpZ2h0O1xuXG4gICAgaWYgKHNjcm9sbFBhcmVudCkge1xuICAgICAgY29uc3Qgc2Nyb2xsUmVjdCA9IHNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QueSB8fCBzY3JvbGxSZWN0LnRvcDtcbiAgICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIHx8IHNjcm9sbFRvcCArIHNjcm9sbFJlY3QuaGVpZ2h0O1xuXG4gICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHNjcm9sbFRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHNjcm9sbEJvdHRvbSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoYm90dG9tIC0gdG9wLCAwKTsgLy8gRGVmYXVsdCB0byAwIGlmIGhlaWdodCBpcyBuZWdhdGl2ZVxuXG4gICAgcmV0dXJuIHsgeTogdG9wLCBoZWlnaHQgfTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmdcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz17YCR7XG4gICAgbW9kYWxJc1Zpc2libGUgPyAnc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZScgOiAnJ1xuICB9IHNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyYH1cbiAgb246dG91Y2htb3ZlPXtfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNofVxuPlxuICA8cGF0aCBkPXtwYXRoRGVmaW5pdGlvbn0gLz5cbjwvc3ZnPlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIge1xuICAgIGhlaWdodDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMG1zIDAuM3MsIG9wYWNpdHkgMC4zcyAwbXM7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHotaW5kZXg6IDk5OTc7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSB7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBvcGFjaXR5OiAwLjU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZS1vdXQsIGhlaWdodCAwcyAwcywgb3BhY2l0eSAwLjNzIDBzO1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUgcGF0aCB7XG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcbiAgfVxuPC9zdHlsZT5cbiIsImltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGNsZWFudXBTdGVwcyB9IGZyb20gJy4vdXRpbHMvY2xlYW51cC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVQcmVmaXgsIHV1aWQgfSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IFNoZXBoZXJkTW9kYWwgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZSc7XG5cbmNvbnN0IFNoZXBoZXJkID0gbmV3IEV2ZW50ZWQoKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHNpdGUgdG91clxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VyIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNvbmZpcm1DYW5jZWwgSWYgdHJ1ZSwgd2lsbCBpc3N1ZSBhIGB3aW5kb3cuY29uZmlybWAgYmVmb3JlIGNhbmNlbGxpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgY29uZmlybSBkaWFsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NQcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGBzaGVwaGVyZC1lbmFibGVkYCBhbmQgYHNoZXBoZXJkLXRhcmdldGAgY2xhc3MgbmFtZXMgYXMgd2VsbCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtc3RlcC1pZGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucyBEZWZhdWx0IG9wdGlvbnMgZm9yIFN0ZXBzICh7QGxpbmsgU3RlcCNjb25zdHJ1Y3Rvcn0pLCBjcmVhdGVkIHRocm91Z2ggYGFkZFN0ZXBgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5leGl0T25Fc2MgRXhpdGluZyB0aGUgdG91ciB3aXRoIHRoZSBlc2NhcGUga2V5IHdpbGwgYmUgZW5hYmxlZCB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5XG4gICAqIHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbiBOYXZpZ2F0aW5nIHRoZSB0b3VyIHZpYSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHdpbGwgYmUgZW5hYmxlZFxuICAgKiB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zdGVwc0NvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIHN0ZXBzLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgc3RlcHMgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMubW9kYWxDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBtb2RhbC5cbiAgICogSWYgbm90IHNldCwgdGhlIG1vZGFsIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge29iamVjdFtdIHwgU3RlcFtdfSBvcHRpb25zLnN0ZXBzIEFuIGFycmF5IG9mIHN0ZXAgb3B0aW9ucyBvYmplY3RzIG9yIFN0ZXAgaW5zdGFuY2VzIHRvIGluaXRpYWxpemUgdGhlIHRvdXIgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b3VyTmFtZSBBbiBvcHRpb25hbCBcIm5hbWVcIiBmb3IgdGhlIHRvdXIuIFRoaXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgdGhlIHRvdXInc1xuICAgKiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgYGlkYCBwcm9wZXJ0eSAtLSB3aGljaCBpcyBhbHNvIHNldCBvbiB0aGUgYGJvZHlgIGVsZW1lbnQgYXMgdGhlIGBkYXRhLXNoZXBoZXJkLWFjdGl2ZS10b3VyYCBhdHRyaWJ1dGVcbiAgICogd2hlbmV2ZXIgdGhlIHRvdXIgYmVjb21lcyBhY3RpdmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy51c2VNb2RhbE92ZXJsYXkgV2hldGhlciBvciBub3Qgc3RlcHMgc2hvdWxkIGJlIHBsYWNlZCBhYm92ZSBhIGRhcmtlbmVkXG4gICAqIG1vZGFsIG92ZXJsYXkuIElmIHRydWUsIHRoZSBvdmVybGF5IHdpbGwgY3JlYXRlIGFuIG9wZW5pbmcgYXJvdW5kIHRoZSB0YXJnZXQgZWxlbWVudCBzbyB0aGF0IGl0XG4gICAqIGNhbiByZW1haW4gaW50ZXJhY3RpdmVcbiAgICogQHJldHVybnMge1RvdXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgZGVmYXVsdFRvdXJPcHRpb25zID0ge1xuICAgICAgZXhpdE9uRXNjOiB0cnVlLFxuICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRUb3VyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IG5vcm1hbGl6ZVByZWZpeCh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpO1xuICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICB0aGlzLmFkZFN0ZXBzKHRoaXMub3B0aW9ucy5zdGVwcyk7XG5cbiAgICAvLyBQYXNzIHRoZXNlIGV2ZW50cyBvbnRvIHRoZSBnbG9iYWwgU2hlcGhlcmQgb2JqZWN0XG4gICAgY29uc3QgZXZlbnRzID0gWydhY3RpdmUnLCAnY2FuY2VsJywgJ2NvbXBsZXRlJywgJ2luYWN0aXZlJywgJ3Nob3cnLCAnc3RhcnQnXTtcbiAgICBldmVudHMubWFwKChldmVudCkgPT4ge1xuICAgICAgKChlKSA9PiB7XG4gICAgICAgIHRoaXMub24oZSwgKG9wdHMpID0+IHtcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICBvcHRzLnRvdXIgPSB0aGlzO1xuICAgICAgICAgIFNoZXBoZXJkLnRyaWdnZXIoZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0VG91cklEKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHN0ZXAgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtPYmplY3R8U3RlcH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBzdGVwIG9wdGlvbnMgb3IgYSBTdGVwIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgb3B0aW9uYWwgaW5kZXggdG8gaW5zZXJ0IHRoZSBzdGVwIGF0LiBJZiB1bmRlZmluZWQsIHRoZSBzdGVwXG4gICAqIGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgYWRkZWQgc3RlcFxuICAgKi9cbiAgYWRkU3RlcChvcHRpb25zLCBpbmRleCkge1xuICAgIGxldCBzdGVwID0gb3B0aW9ucztcblxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBTdGVwKSkge1xuICAgICAgc3RlcCA9IG5ldyBTdGVwKHRoaXMsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwLnRvdXIgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICghaXNVbmRlZmluZWQoaW5kZXgpKSB7XG4gICAgICB0aGlzLnN0ZXBzLnNwbGljZShpbmRleCwgMCwgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgc3RlcHMgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+IHwgQXJyYXk8U3RlcD59IHN0ZXBzIFRoZSBzdGVwcyB0byBhZGQgdG8gdGhlIHRvdXJcbiAgICovXG4gIGFkZFN0ZXBzKHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzdGVwIGluIHRoZSB0b3VyXG4gICAqL1xuICBiYWNrKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIHRoaXMuc2hvdyhpbmRleCAtIDEsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlICdjYW5jZWwnIGV2ZW50XG4gICAqIElmIGBjb25maXJtQ2FuY2VsYCBpcyB0cnVlLCB3aWxsIHNob3cgYSB3aW5kb3cuY29uZmlybSBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbCkge1xuICAgICAgY29uc3QgY2FuY2VsTWVzc2FnZSA9IHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSB8fCAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHN0b3AgdGhlIHRvdXI/JztcbiAgICAgIGNvbnN0IHN0b3BUb3VyID0gd2luZG93LmNvbmZpcm0oY2FuY2VsTWVzc2FnZSk7XG4gICAgICBpZiAoc3RvcFRvdXIpIHtcbiAgICAgICAgdGhpcy5fZG9uZSgnY2FuY2VsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlIGBjb21wbGV0ZWAgZXZlbnRcbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMuX2RvbmUoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RlcCBmcm9tIGEgZ2l2ZW4gaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIHN0ZXAgdG8gcmV0cmlldmVcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIHN0ZXAgY29ycmVzcG9uZGluZyB0byB0aGUgYGlkYFxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLmZpbmQoKHN0ZXApID0+IHtcbiAgICAgIHJldHVybiBzdGVwLmlkID09PSBpZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0ZXBcbiAgICogQHJldHVybnMge1N0ZXB8bnVsbH1cbiAgICovXG4gIGdldEN1cnJlbnRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGN1cnJlbnQgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBjb25zdCBjdXJyZW50U3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIGlmIChjdXJyZW50U3RlcCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRvdXIgaXMgYWN0aXZlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gU2hlcGhlcmQuYWN0aXZlVG91ciA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgbmV4dCBzdGVwIGluIHRoZSB0b3VyXG4gICAqIElmIHdlIGFyZSBhdCB0aGUgZW5kLCBjYWxsIGBjb21wbGV0ZWBcbiAgICovXG4gIG5leHQoKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coaW5kZXggKyAxLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3RlcCBmcm9tIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBpZCBmb3IgdGhlIHN0ZXAgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTdGVwKG5hbWUpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpO1xuXG4gICAgLy8gRmluZCB0aGUgc3RlcCwgZGVzdHJveSBpdCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhpcy5zdGVwc1xuICAgIHRoaXMuc3RlcHMuc29tZSgoc3RlcCwgaSkgPT4ge1xuICAgICAgaWYgKHN0ZXAuaWQgPT09IG5hbWUpIHtcbiAgICAgICAgaWYgKHN0ZXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICBzdGVwLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXAuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0ZXBzLnNwbGljZShpLCAxKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaWQgPT09IG5hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgc3RlcHMgbGVmdCwgc2hvdyB0aGUgZmlyc3Qgb25lLCBvdGhlcndpc2UganVzdCBjYW5jZWwgdGhlIHRvdXJcbiAgICAgIHRoaXMuc3RlcHMubGVuZ3RoID8gdGhpcy5zaG93KDApIDogdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhIHNwZWNpZmljIHN0ZXAgaW4gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSB0byBsb29rIHVwIHRoZSBzdGVwIGJ5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKi9cbiAgc2hvdyhrZXkgPSAwLCBmb3J3YXJkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN0ZXAgPSBpc1N0cmluZyhrZXkpID8gdGhpcy5nZXRCeUlkKGtleSkgOiB0aGlzLnN0ZXBzW2tleV07XG5cbiAgICBpZiAoc3RlcCkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGVCZWZvcmVTaG93KCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZFNraXBTdGVwID0gaXNGdW5jdGlvbihzdGVwLm9wdGlvbnMuc2hvd09uKSAmJiAhc3RlcC5vcHRpb25zLnNob3dPbigpO1xuXG4gICAgICAvLyBJZiBgc2hvd09uYCByZXR1cm5zIGZhbHNlLCB3ZSB3YW50IHRvIHNraXAgdGhlIHN0ZXAsIG90aGVyd2lzZSwgc2hvdyB0aGUgc3RlcCBsaWtlIG5vcm1hbFxuICAgICAgaWYgKHNob3VsZFNraXBTdGVwKSB7XG4gICAgICAgIHRoaXMuX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jywge1xuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgcHJldmlvdXM6IHRoaXMuY3VycmVudFN0ZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHN0ZXA7XG4gICAgICAgIHN0ZXAuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgdG91clxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xuXG4gICAgLy8gU2F2ZSB0aGUgZm9jdXNlZCBlbGVtZW50IGJlZm9yZSB0aGUgdG91ciBvcGVuc1xuICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gbnVsbDtcblxuICAgIHRoaXMuX3NldHVwTW9kYWwoKTtcblxuICAgIHRoaXMuX3NldHVwQWN0aXZlVG91cigpO1xuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciB0aGUgdG91ciBpcyBjYW5jZWxsZWQgb3IgY29tcGxldGVkLCBiYXNpY2FsbHkgYW55dGltZSB3ZSBleGl0IHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9uZShldmVudCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3RlcHMpKSB7XG4gICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHN0ZXAuZGVzdHJveSgpKTtcbiAgICB9XG5cbiAgICBjbGVhbnVwU3RlcHModGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIHsgaW5kZXggfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXIoJ2luYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgIHRoaXMubW9kYWwuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2NhbmNlbCcgfHwgZXZlbnQgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyJyk7XG5cbiAgICAgICAgaWYgKG1vZGFsQ29udGFpbmVyKSB7XG4gICAgICAgICAgbW9kYWxDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgdG91ciBzdGFydGVkXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuKSkge1xuICAgICAgdGhpcy5mb2N1c2VkRWxCZWZvcmVPcGVuLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyB0b3VyIFwiYWN0aXZlXCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEFjdGl2ZVRvdXIoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdhY3RpdmUnLCB7IHRvdXI6IHRoaXMgfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBfc2V0dXBNb2RhbCBjcmVhdGUgdGhlIG1vZGFsIGNvbnRhaW5lciBhbmQgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cE1vZGFsKCkge1xuICAgIHRoaXMubW9kYWwgPSBuZXcgU2hlcGhlcmRNb2RhbCh7XG4gICAgICB0YXJnZXQ6IHRoaXMub3B0aW9ucy5tb2RhbENvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgcHJvcHM6XG4gICAgICB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYHNob3dPbmAgZXZhbHVhdGVzIHRvIGZhbHNlLCB0byBza2lwIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCB0byBza2lwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZihzdGVwKTtcbiAgICBjb25zdCBuZXh0SW5kZXggPSBmb3J3YXJkID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgIHRoaXMuc2hvdyhuZXh0SW5kZXgsIGZvcndhcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBzaG93aW5nLCBoaWRlIHRoZSBjdXJyZW50IHN0ZXAgYW5kIGlmIHRoZSB0b3VyIGlzIG5vdFxuICAgKiBhbHJlYWR5IGFjdGl2ZSwgY2FsbCBgdGhpcy5fc2V0dXBBY3RpdmVUb3VyYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGF0ZUJlZm9yZVNob3coKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzLmlkIHRvIGAke3RvdXJOYW1lfS0tJHt1dWlkfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRUb3VySUQoKSB7XG4gICAgY29uc3QgdG91ck5hbWUgPSB0aGlzLm9wdGlvbnMudG91ck5hbWUgfHwgJ3RvdXInO1xuXG4gICAgdGhpcy5pZCA9IGAke3RvdXJOYW1lfS0tJHt1dWlkKCl9YDtcbiAgfVxufVxuXG5leHBvcnQgeyBTaGVwaGVyZCB9O1xuIiwiaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgeyBTaGVwaGVyZCwgVG91ciB9IGZyb20gJy4vdG91ci5qcyc7XG5cbk9iamVjdC5hc3NpZ24oU2hlcGhlcmQsIHsgVG91ciwgU3RlcCB9KTtcblxuZXhwb3J0IGRlZmF1bHQgU2hlcGhlcmQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ })));