(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/datatables-select-bs5/select.bootstrap5.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/datatables-select-bs5/select.bootstrap5.js":
/*!*********************************************************!*\
  !*** ./libs/datatables-select-bs5/select.bootstrap5.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var datatables_net_select_bs5_js_select_bootstrap5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-select-bs5/js/select.bootstrap5 */ \"./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js\");\n/* harmony import */ var datatables_net_select_bs5_js_select_bootstrap5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datatables_net_select_bs5_js_select_bootstrap5__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL2RhdGF0YWJsZXMtc2VsZWN0LWJzNS9zZWxlY3QuYm9vdHN0cmFwNS5qcz81NTZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiIuL2xpYnMvZGF0YXRhYmxlcy1zZWxlY3QtYnM1L3NlbGVjdC5ib290c3RyYXA1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdkYXRhdGFibGVzLm5ldC1zZWxlY3QtYnM1L2pzL3NlbGVjdC5ib290c3RyYXA1JztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/datatables-select-bs5/select.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js":
/*!************************************************************************!*\
  !*** ./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 styling wrapper for Select\n * Â©2021 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net-bs5 */ \"./node_modules/datatables.net-select-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js\"), __webpack_require__(/*! datatables.net-select */ \"./node_modules/datatables.net-select-bs5/node_modules/datatables.net-select/js/dataTables.select.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n\nreturn $.fn.dataTable;\n\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0LWJzNS9qcy9zZWxlY3QuYm9vdHN0cmFwNS5qcz9kYzkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxFQUFFLGlDQUFRLENBQUMsMkNBQVEsRUFBRSxxSkFBb0IsRUFBRSx1SkFBdUIsQ0FBQyxtQ0FBRTtBQUNyRTtBQUNBLEdBQUc7QUFBQSxvR0FBRTtBQUNMO0FBQ0EsTUFBTSxFQXFCSjtBQUNGLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zZWxlY3QtYnM1L2pzL3NlbGVjdC5ib290c3RyYXA1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIEJvb3RzdHJhcCA1IHN0eWxpbmcgd3JhcHBlciBmb3IgU2VsZWN0XG4gKiDCqTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldC1iczUnLCAnZGF0YXRhYmxlcy5uZXQtc2VsZWN0J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcblx0XHRcdFx0JCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJzNScpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkLmZuLmRhdGFUYWJsZS5zZWxlY3QgKSB7XG5cdFx0XHRcdHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LXNlbGVjdCcpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbnJldHVybiAkLmZuLmRhdGFUYWJsZTtcblxufSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-select-bs5/js/select.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-select-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/datatables.net-select-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 5 integration\n * 2020 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * DataTables integration for Bootstrap 4. This requires Bootstrap 5 and\n * DataTables 1.10 or newer.\n *\n * This file sets the defaults and adds options to DataTables to style its\n * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap\n * for further information.\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/* Set the defaults for DataTables initialisation */\n$.extend( true, DataTable.defaults, {\n\tdom:\n\t\t\"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>\" +\n\t\t\"<'row'<'col-sm-12'tr>>\" +\n\t\t\"<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>\",\n\trenderer: 'bootstrap'\n} );\n\n\n/* Default class modification */\n$.extend( DataTable.ext.classes, {\n\tsWrapper:      \"dataTables_wrapper dt-bootstrap5\",\n\tsFilterInput:  \"form-control form-control-sm\",\n\tsLengthSelect: \"form-select form-select-sm\",\n\tsProcessing:   \"dataTables_processing card\",\n\tsPageButton:   \"paginate_button page-item\"\n} );\n\n\n/* Bootstrap paging button renderer */\nDataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {\n\tvar api     = new DataTable.Api( settings );\n\tvar classes = settings.oClasses;\n\tvar lang    = settings.oLanguage.oPaginate;\n\tvar aria = settings.oLanguage.oAria.paginate || {};\n\tvar btnDisplay, btnClass, counter=0;\n\n\tvar attach = function( container, buttons ) {\n\t\tvar i, ien, node, button;\n\t\tvar clickHandler = function ( e ) {\n\t\t\te.preventDefault();\n\t\t\tif ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {\n\t\t\t\tapi.page( e.data.action ).draw( 'page' );\n\t\t\t}\n\t\t};\n\n\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tbutton = buttons[i];\n\n\t\t\tif ( Array.isArray( button ) ) {\n\t\t\t\tattach( container, button );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbtnDisplay = '';\n\t\t\t\tbtnClass = '';\n\n\t\t\t\tswitch ( button ) {\n\t\t\t\t\tcase 'ellipsis':\n\t\t\t\t\t\tbtnDisplay = '&#x2026;';\n\t\t\t\t\t\tbtnClass = 'disabled';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'first':\n\t\t\t\t\t\tbtnDisplay = lang.sFirst;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'previous':\n\t\t\t\t\t\tbtnDisplay = lang.sPrevious;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'next':\n\t\t\t\t\t\tbtnDisplay = lang.sNext;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'last':\n\t\t\t\t\t\tbtnDisplay = lang.sLast;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbtnDisplay = button + 1;\n\t\t\t\t\t\tbtnClass = page === button ?\n\t\t\t\t\t\t\t'active' : '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( btnDisplay ) {\n\t\t\t\t\tnode = $('<li>', {\n\t\t\t\t\t\t\t'class': classes.sPageButton+' '+btnClass,\n\t\t\t\t\t\t\t'id': idx === 0 && typeof button === 'string' ?\n\t\t\t\t\t\t\t\tsettings.sTableId +'_'+ button :\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.append( $('<a>', {\n\t\t\t\t\t\t\t\t'href': '#',\n\t\t\t\t\t\t\t\t'aria-controls': settings.sTableId,\n\t\t\t\t\t\t\t\t'aria-label': aria[ button ],\n\t\t\t\t\t\t\t\t'data-dt-idx': counter,\n\t\t\t\t\t\t\t\t'tabindex': settings.iTabIndex,\n\t\t\t\t\t\t\t\t'class': 'page-link'\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t.html( btnDisplay )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.appendTo( container );\n\n\t\t\t\t\tsettings.oApi._fnBindAction(\n\t\t\t\t\t\tnode, {action: button}, clickHandler\n\t\t\t\t\t);\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// IE9 throws an 'unknown error' if document.activeElement is used\n\t// inside an iframe or frame. \n\tvar activeEl;\n\n\ttry {\n\t\t// Because this approach is destroying and recreating the paging\n\t\t// elements, focus is lost on the select button which is bad for\n\t\t// accessibility. So we want to restore focus once the draw has\n\t\t// completed\n\t\tactiveEl = $(host).find(document.activeElement).data('dt-idx');\n\t}\n\tcatch (e) {}\n\n\tattach(\n\t\t$(host).empty().html('<ul class=\"pagination\"/>').children('ul'),\n\t\tbuttons\n\t);\n\n\tif ( activeEl !== undefined ) {\n\t\t$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');\n\t}\n};\n\n\nreturn DataTable;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0LWJzNS9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnM1L2pzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNS5qcz84Y2E1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLDJDQUFRLEVBQUUsMkRBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsb0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFvQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zZWxlY3QtYnM1L25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1iczUvanMvZGF0YVRhYmxlcy5ib290c3RyYXA1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIERhdGFUYWJsZXMgQm9vdHN0cmFwIDUgaW50ZWdyYXRpb25cbiAqIDIwMjAgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIERhdGFUYWJsZXMgaW50ZWdyYXRpb24gZm9yIEJvb3RzdHJhcCA0LiBUaGlzIHJlcXVpcmVzIEJvb3RzdHJhcCA1IGFuZFxuICogRGF0YVRhYmxlcyAxLjEwIG9yIG5ld2VyLlxuICpcbiAqIFRoaXMgZmlsZSBzZXRzIHRoZSBkZWZhdWx0cyBhbmQgYWRkcyBvcHRpb25zIHRvIERhdGFUYWJsZXMgdG8gc3R5bGUgaXRzXG4gKiBjb250cm9scyB1c2luZyBCb290c3RyYXAuIFNlZSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbWFudWFsL3N0eWxpbmcvYm9vdHN0cmFwXG4gKiBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQvLyBSZXF1aXJlIERhdGFUYWJsZXMsIHdoaWNoIGF0dGFjaGVzIHRvIGpRdWVyeSwgaW5jbHVkaW5nXG5cdFx0XHRcdC8vIGpRdWVyeSBpZiBuZWVkZWQgYW5kIGhhdmUgYSAkIHByb3BlcnR5IHNvIHdlIGNhbiBhY2Nlc3MgdGhlXG5cdFx0XHRcdC8vIGpRdWVyeSBvYmplY3QgdGhhdCBpcyB1c2VkXG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vKiBTZXQgdGhlIGRlZmF1bHRzIGZvciBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uICovXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmRlZmF1bHRzLCB7XG5cdGRvbTpcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC02J2w+PCdjb2wtc20tMTIgY29sLW1kLTYnZj4+XCIgK1xuXHRcdFwiPCdyb3cnPCdjb2wtc20tMTIndHI+PlwiICtcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC01J2k+PCdjb2wtc20tMTIgY29sLW1kLTcncD4+XCIsXG5cdHJlbmRlcmVyOiAnYm9vdHN0cmFwJ1xufSApO1xuXG5cbi8qIERlZmF1bHQgY2xhc3MgbW9kaWZpY2F0aW9uICovXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdHNXcmFwcGVyOiAgICAgIFwiZGF0YVRhYmxlc193cmFwcGVyIGR0LWJvb3RzdHJhcDVcIixcblx0c0ZpbHRlcklucHV0OiAgXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsXG5cdHNMZW5ndGhTZWxlY3Q6IFwiZm9ybS1zZWxlY3QgZm9ybS1zZWxlY3Qtc21cIixcblx0c1Byb2Nlc3Npbmc6ICAgXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmcgY2FyZFwiLFxuXHRzUGFnZUJ1dHRvbjogICBcInBhZ2luYXRlX2J1dHRvbiBwYWdlLWl0ZW1cIlxufSApO1xuXG5cbi8qIEJvb3RzdHJhcCBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyICovXG5EYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b24uYm9vdHN0cmFwID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0dmFyIGFwaSAgICAgPSBuZXcgRGF0YVRhYmxlLkFwaSggc2V0dGluZ3MgKTtcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIGxhbmcgICAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cblx0dmFyIGF0dGFjaCA9IGZ1bmN0aW9uKCBjb250YWluZXIsIGJ1dHRvbnMgKSB7XG5cdFx0dmFyIGksIGllbiwgbm9kZSwgYnV0dG9uO1xuXHRcdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRpZiAoICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgYXBpLnBhZ2UoKSAhPSBlLmRhdGEuYWN0aW9uICkge1xuXHRcdFx0XHRhcGkucGFnZSggZS5kYXRhLmFjdGlvbiApLmRyYXcoICdwYWdlJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBidXR0b24gKSApIHtcblx0XHRcdFx0YXR0YWNoKCBjb250YWluZXIsIGJ1dHRvbiApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGJ0bkRpc3BsYXkgPSAnJztcblx0XHRcdFx0YnRuQ2xhc3MgPSAnJztcblxuXHRcdFx0XHRzd2l0Y2ggKCBidXR0b24gKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9ICcmI3gyMDI2Oyc7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9ICdkaXNhYmxlZCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlIDwgcGFnZXMtMSA/XG5cdFx0XHRcdFx0XHRcdCcnIDogJyBkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsYXN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzLTEgP1xuXHRcdFx0XHRcdFx0XHQnJyA6ICcgZGlzYWJsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBidXR0b24gKyAxO1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHQnYWN0aXZlJyA6ICcnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ0bkRpc3BsYXkgKSB7XG5cdFx0XHRcdFx0bm9kZSA9ICQoJzxsaT4nLCB7XG5cdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHQnaWQnOiBpZHggPT09IDAgJiYgdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLnNUYWJsZUlkICsnXycrIGJ1dHRvbiA6XG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0J2hyZWYnOiAnIycsXG5cdFx0XHRcdFx0XHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdCdkYXRhLWR0LWlkeCc6IGNvdW50ZXIsXG5cdFx0XHRcdFx0XHRcdFx0J3RhYmluZGV4Jzogc2V0dGluZ3MuaVRhYkluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6ICdwYWdlLWxpbmsnXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHQuaHRtbCggYnRuRGlzcGxheSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdFx0c2V0dGluZ3Mub0FwaS5fZm5CaW5kQWN0aW9uKFxuXHRcdFx0XHRcdFx0bm9kZSwge2FjdGlvbjogYnV0dG9ufSwgY2xpY2tIYW5kbGVyXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcblx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gXG5cdHZhciBhY3RpdmVFbDtcblxuXHR0cnkge1xuXHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0Ly8gY29tcGxldGVkXG5cdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdH1cblx0Y2F0Y2ggKGUpIHt9XG5cblx0YXR0YWNoKFxuXHRcdCQoaG9zdCkuZW1wdHkoKS5odG1sKCc8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCIvPicpLmNoaWxkcmVuKCd1bCcpLFxuXHRcdGJ1dHRvbnNcblx0KTtcblxuXHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0JChob3N0KS5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkudHJpZ2dlcignZm9jdXMnKTtcblx0fVxufTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-select-bs5/node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-select-bs5/node_modules/datatables.net-select/js/dataTables.select.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/datatables.net-select-bs5/node_modules/datatables.net-select/js/dataTables.select.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Select for DataTables 1.4.0-dev\n * 2015-2021 SpryMedia Ltd - datatables.net/license/mit\n */\n\n/**\n * @summary     Select for DataTables\n * @description A collection of API methods, events and buttons for DataTables\n *   that provides selection options of the items in a DataTable\n * @version     1.4.0-dev\n * @file        dataTables.select.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     datatables.net/forums\n * @copyright   Copyright 2015-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net/extensions/select\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n// Version information for debugger\nDataTable.select = {};\n\nDataTable.select.version = '1.4.0-dev';\n\nDataTable.select.init = function ( dt ) {\n\tvar ctx = dt.settings()[0];\n\n\tif (ctx._select) {\n\t\treturn;\n\t}\n\n\tvar savedSelected = dt.state.loaded();\n\n\tvar selectAndSave = function(e, settings, data) {\n\t\tif(data === null || data.select === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear any currently selected rows, before restoring state\n\t\t// None will be selected on first initialisation\n\t\tif (dt.rows({selected: true}).any()) {\n\t\t\tdt.rows().deselect();\n\t\t}\n\t\tif (data.select.rows !== undefined) {\n\t\t\tdt.rows(data.select.rows).select();\n\t\t}\n\n\t\tif (dt.columns({selected: true}).any()) {\n\t\t\tdt.columns().deselect();\n\t\t}\n\t\tif (data.select.columns !== undefined) {\n\t\t\tdt.columns(data.select.columns).select();\n\t\t}\n\n\t\tif (dt.cells({selected: true}).any()) {\n\t\t\tdt.cells().deselect();\n\t\t}\n\t\tif (data.select.cells !== undefined) {\n\t\t\tfor(var i = 0; i < data.select.cells.length; i++) {\n\t\t\t\tdt.cell(data.select.cells[i].row, data.select.cells[i].column).select();\n\t\t\t}\n\t\t}\n\t\tdt.state.save();\n\t}\n\t\n\tdt.one('init', function() {\n\t\tdt.on('stateSaveParams', function(e, settings, data) {\n\t\t\tdata.select = {};\n\t\t\tdata.select.rows = dt.rows({selected:true}).ids(true).toArray();\n\t\t\tdata.select.columns = dt.columns({selected:true})[0];\n\t\t\tdata.select.cells = dt.cells({selected:true})[0].map(function(coords) {\n\t\t\t\treturn {row: dt.row(coords.row).id(true), column: coords.column}\n\t\t\t});\n\t\t})\n\t\t\n\t\tselectAndSave(undefined, undefined, savedSelected)\n\t\tdt.on('stateLoaded stateLoadParams', selectAndSave)\n\t})\n\n\tvar init = ctx.oInit.select;\n\tvar defaults = DataTable.defaults.select;\n\tvar opts = init === undefined ?\n\t\tdefaults :\n\t\tinit;\n\n\t// Set defaults\n\tvar items = 'row';\n\tvar style = 'api';\n\tvar blurable = false;\n\tvar toggleable = true;\n\tvar info = true;\n\tvar selector = 'td, th';\n\tvar className = 'selected';\n\tvar setStyle = false;\n\n\tctx._select = {};\n\n\t// Initialisation customisations\n\tif ( opts === true ) {\n\t\tstyle = 'os';\n\t\tsetStyle = true;\n\t}\n\telse if ( typeof opts === 'string' ) {\n\t\tstyle = opts;\n\t\tsetStyle = true;\n\t}\n\telse if ( $.isPlainObject( opts ) ) {\n\t\tif ( opts.blurable !== undefined ) {\n\t\t\tblurable = opts.blurable;\n\t\t}\n\t\t\n\t\tif ( opts.toggleable !== undefined ) {\n\t\t\ttoggleable = opts.toggleable;\n\t\t}\n\n\t\tif ( opts.info !== undefined ) {\n\t\t\tinfo = opts.info;\n\t\t}\n\n\t\tif ( opts.items !== undefined ) {\n\t\t\titems = opts.items;\n\t\t}\n\n\t\tif ( opts.style !== undefined ) {\n\t\t\tstyle = opts.style;\n\t\t\tsetStyle = true;\n\t\t}\n\t\telse {\n\t\t\tstyle = 'os';\n\t\t\tsetStyle = true;\n\t\t}\n\n\t\tif ( opts.selector !== undefined ) {\n\t\t\tselector = opts.selector;\n\t\t}\n\n\t\tif ( opts.className !== undefined ) {\n\t\t\tclassName = opts.className;\n\t\t}\n\t}\n\n\tdt.select.selector( selector );\n\tdt.select.items( items );\n\tdt.select.style( style );\n\tdt.select.blurable( blurable );\n\tdt.select.toggleable( toggleable );\n\tdt.select.info( info );\n\tctx._select.className = className;\n\n\n\t// Sort table based on selected rows. Requires Select Datatables extension\n\t$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {\n\t\treturn this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {\n\t\t\tif ( settings._select.items === 'row' ) {\n\t\t\t\treturn $( td ).parent().hasClass( settings._select.className );\n\t\t\t} else if ( settings._select.items === 'cell' ) {\n\t\t\t\treturn $( td ).hasClass( settings._select.className );\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t};\n\n\t// If the init options haven't enabled select, but there is a selectable\n\t// class name, then enable\n\tif ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {\n\t\tdt.select.style( 'os' );\n\t}\n};\n\n/*\n\nSelect is a collection of API methods, event handlers, event emitters and\nbuttons (for the `Buttons` extension) for DataTables. It provides the following\nfeatures, with an overview of how they are implemented:\n\n## Selection of rows, columns and cells. Whether an item is selected or not is\n   stored in:\n\n* rows: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoData` object for each row\n* columns: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoColumns` object for each column\n* cells: a `_selected_cells` property which contains an array of boolean values\n  of the `aoData` object for each row. The array is the same length as the\n  columns array, with each element of it representing a cell.\n\nThis method of using boolean flags allows Select to operate when nodes have not\nbeen created for rows / cells (DataTables' defer rendering feature).\n\n## API methods\n\nA range of API methods are available for triggering selection and de-selection\nof rows. Methods are also available to configure the selection events that can\nbe triggered by an end user (such as which items are to be selected). To a large\nextent, these of API methods *is* Select. It is basically a collection of helper\nfunctions that can be used to select items in a DataTable.\n\nConfiguration of select is held in the object `_select` which is attached to the\nDataTables settings object on initialisation. Select being available on a table\nis not optional when Select is loaded, but its default is for selection only to\nbe available via the API - so the end user wouldn't be able to select rows\nwithout additional configuration.\n\nThe `_select` object contains the following properties:\n\n```\n{\n\titems:string       - Can be `rows`, `columns` or `cells`. Defines what item \n\t                     will be selected if the user is allowed to activate row\n\t                     selection using the mouse.\n\tstyle:string       - Can be `none`, `single`, `multi` or `os`. Defines the\n\t                     interaction style when selecting items\n\tblurable:boolean   - If row selection can be cleared by clicking outside of\n\t                     the table\n\ttoggleable:boolean - If row selection can be cancelled by repeated clicking\n\t                     on the row\n\tinfo:boolean       - If the selection summary should be shown in the table\n\t                     information elements\n}\n```\n\nIn addition to the API methods, Select also extends the DataTables selector\noptions for rows, columns and cells adding a `selected` option to the selector\noptions object, allowing the developer to select only selected items or\nunselected items.\n\n## Mouse selection of items\n\nClicking on items can be used to select items. This is done by a simple event\nhandler that will select the items using the API methods.\n\n */\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local functions\n */\n\n/**\n * Add one or more cells to the selection when shift clicking in OS selection\n * style cell selection.\n *\n * Cell range is more complicated than row and column as we want to select\n * in the visible grid rather than by index in sequence. For example, if you\n * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1\n * should also be selected (and not 1-3, 1-4. etc)\n * \n * @param  {DataTable.Api} dt   DataTable\n * @param  {object}        idx  Cell index to select to\n * @param  {object}        last Cell index to select from\n * @private\n */\nfunction cellRange( dt, idx, last )\n{\n\tvar indexes;\n\tvar columnIndexes;\n\tvar rowIndexes;\n\tvar selectColumns = function ( start, end ) {\n\t\tif ( start > end ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\t\t\n\t\tvar record = false;\n\t\treturn dt.columns( ':visible' ).indexes().filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) { // not else if, as start might === end\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tvar selectRows = function ( start, end ) {\n\t\tvar indexes = dt.rows( { search: 'applied' } ).indexes();\n\n\t\t// Which comes first - might need to swap\n\t\tif ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn indexes.filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) {\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tif ( ! dt.cells( { selected: true } ).any() && ! last ) {\n\t\t// select from the top left cell to this one\n\t\tcolumnIndexes = selectColumns( 0, idx.column );\n\t\trowIndexes = selectRows( 0 , idx.row );\n\t}\n\telse {\n\t\t// Get column indexes between old and new\n\t\tcolumnIndexes = selectColumns( last.column, idx.column );\n\t\trowIndexes = selectRows( last.row , idx.row );\n\t}\n\n\tindexes = dt.cells( rowIndexes, columnIndexes ).flatten();\n\n\tif ( ! dt.cells( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt.cells( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range\n\t\tdt.cells( indexes ).deselect();\n\t}\n}\n\n/**\n * Disable mouse selection by removing the selectors\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction disableMouseSelection( dt )\n{\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\n\t$( dt.table().container() )\n\t\t.off( 'mousedown.dtSelect', selector )\n\t\t.off( 'mouseup.dtSelect', selector )\n\t\t.off( 'click.dtSelect', selector );\n\n\t$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );\n}\n\n/**\n * Attach mouse listeners to the table to allow mouse selection of items\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction enableMouseSelection ( dt )\n{\n\tvar container = $( dt.table().container() );\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\tvar matchSelection;\n\n\tcontainer\n\t\t.on( 'mousedown.dtSelect', selector, function(e) {\n\t\t\t// Disallow text selection for shift clicking on the table so multi\n\t\t\t// element selection doesn't look terrible!\n\t\t\tif ( e.shiftKey || e.metaKey || e.ctrlKey ) {\n\t\t\t\tcontainer\n\t\t\t\t\t.css( '-moz-user-select', 'none' )\n\t\t\t\t\t.one('selectstart.dtSelect', selector, function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} );\n\t\t\t}\n\n\t\t\tif ( window.getSelection ) {\n\t\t\t\tmatchSelection = window.getSelection();\n\t\t\t}\n\t\t} )\n\t\t.on( 'mouseup.dtSelect', selector, function() {\n\t\t\t// Allow text selection to occur again, Mozilla style (tested in FF\n\t\t\t// 35.0.1 - still required)\n\t\t\tcontainer.css( '-moz-user-select', '' );\n\t\t} )\n\t\t.on( 'click.dtSelect', selector, function ( e ) {\n\t\t\tvar items = dt.select.items();\n\t\t\tvar idx;\n\n\t\t\t// If text was selected (click and drag), then we shouldn't change\n\t\t\t// the row's selected state\n\t\t\tif ( matchSelection ) {\n\t\t\t\tvar selection = window.getSelection();\n\n\t\t\t\t// If the element that contains the selection is not in the table, we can ignore it\n\t\t\t\t// This can happen if the developer selects text from the click event\n\t\t\t\tif ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {\n\t\t\t\t\tif ( selection !== matchSelection ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = dt.settings()[0];\n\t\t\tvar wrapperClass = dt.settings()[0].oClasses.sWrapper.trim().replace(/ +/g, '.');\n\n\t\t\t// Ignore clicks inside a sub-table\n\t\t\tif ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cell = dt.cell( $(e.target).closest('td, th') );\n\n\t\t\t// Check the cell actually belongs to the host DataTable (so child\n\t\t\t// rows, etc, are ignored)\n\t\t\tif ( ! cell.any() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('user-select.dt');\n\t\t\teventTrigger( dt, event, [ items, cell, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cellIndex = cell.index();\n\t\t\tif ( items === 'row' ) {\n\t\t\t\tidx = cellIndex.row;\n\t\t\t\ttypeSelect( e, dt, ctx, 'row', idx );\n\t\t\t}\n\t\t\telse if ( items === 'column' ) {\n\t\t\t\tidx = cell.index().column;\n\t\t\t\ttypeSelect( e, dt, ctx, 'column', idx );\n\t\t\t}\n\t\t\telse if ( items === 'cell' ) {\n\t\t\t\tidx = cell.index();\n\t\t\t\ttypeSelect( e, dt, ctx, 'cell', idx );\n\t\t\t}\n\n\t\t\tctx._select_lastCell = cellIndex;\n\t\t} );\n\n\t// Blurable\n\t$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {\n\t\tif ( ctx._select.blurable ) {\n\t\t\t// If the click was inside the DataTables container, don't blur\n\t\t\tif ( $(e.target).parents().filter( dt.table().container() ).length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore elements which have been removed from the DOM (i.e. paging\n\t\t\t// buttons)\n\t\t\tif ( $(e.target).parents('html').length === 0 ) {\n\t\t\t \treturn;\n\t\t\t}\n\n\t\t\t// Don't blur in Editor form\n\t\t\tif ( $(e.target).parents('div.DTE').length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('select-blur.dt');\n\t\t\teventTrigger( dt, event, [ e.target, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear( ctx, true );\n\t\t}\n\t} );\n}\n\n/**\n * Trigger an event on a DataTable\n *\n * @param {DataTable.Api} api      DataTable to trigger events on\n * @param  {boolean}      selected true if selected, false if deselected\n * @param  {string}       type     Item type acting on\n * @param  {boolean}      any      Require that there are values before\n *     triggering\n * @private\n */\nfunction eventTrigger ( api, type, args, any )\n{\n\tif ( any && ! api.flatten().length ) {\n\t\treturn;\n\t}\n\n\tif ( typeof type === 'string' ) {\n\t\ttype = type +'.dt';\n\t}\n\n\targs.unshift( api );\n\n\t$(api.table().node()).trigger( type, args );\n}\n\n/**\n * Update the information element of the DataTable showing information about the\n * items selected. This is done by adding tags to the existing text\n * \n * @param {DataTable.Api} api DataTable to update\n * @private\n */\nfunction info ( api )\n{\n\tvar ctx = api.settings()[0];\n\n\tif ( ! ctx._select.info || ! ctx.aanFeatures.i ) {\n\t\treturn;\n\t}\n\n\tif ( api.select.style() === 'api' ) {\n\t\treturn;\n\t}\n\n\tvar rows    = api.rows( { selected: true } ).flatten().length;\n\tvar columns = api.columns( { selected: true } ).flatten().length;\n\tvar cells   = api.cells( { selected: true } ).flatten().length;\n\n\tvar add = function ( el, name, num ) {\n\t\tel.append( $('<span class=\"select-item\"/>').append( api.i18n(\n\t\t\t'select.'+name+'s',\n\t\t\t{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },\n\t\t\tnum\n\t\t) ) );\n\t};\n\n\t// Internal knowledge of DataTables to loop over all information elements\n\t$.each( ctx.aanFeatures.i, function ( i, el ) {\n\t\tel = $(el);\n\n\t\tvar output  = $('<span class=\"select-info\"/>');\n\t\tadd( output, 'row', rows );\n\t\tadd( output, 'column', columns );\n\t\tadd( output, 'cell', cells  );\n\n\t\tvar exisiting = el.children('span.select-info');\n\t\tif ( exisiting.length ) {\n\t\t\texisiting.remove();\n\t\t}\n\n\t\tif ( output.text() !== '' ) {\n\t\t\tel.append( output );\n\t\t}\n\t} );\n}\n\n/**\n * Initialisation of a new table. Attach event handlers and callbacks to allow\n * Select to operate correctly.\n *\n * This will occur _after_ the initial DataTables initialisation, although\n * before Ajax data is rendered, if there is ajax data\n *\n * @param  {DataTable.settings} ctx Settings object to operate on\n * @private\n */\nfunction init ( ctx ) {\n\tvar api = new DataTable.Api( ctx );\n\tctx._select_init = true;\n\n\t// Row callback so that classes can be added to rows and cells if the item\n\t// was selected before the element was created. This will happen with the\n\t// `deferRender` option enabled.\n\t// \n\t// This method of attaching to `aoRowCreatedCallback` is a hack until\n\t// DataTables has proper events for row manipulation If you are reviewing\n\t// this code to create your own plug-ins, please do not do this!\n\tctx.aoRowCreatedCallback.push( {\n\t\tfn: function ( row, data, index ) {\n\t\t\tvar i, ien;\n\t\t\tvar d = ctx.aoData[ index ];\n\n\t\t\t// Row\n\t\t\tif ( d._select_selected ) {\n\t\t\t\t$( row ).addClass( ctx._select.className );\n\t\t\t}\n\n\t\t\t// Cells and columns - if separated out, we would need to do two\n\t\t\t// loops, so it makes sense to combine them into a single one\n\t\t\tfor ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {\n\t\t\t\tif ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {\n\t\t\t\t\t$(d.anCells[i]).addClass( ctx._select.className );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsName: 'select-deferRender'\n\t} );\n\n\t// On Ajax reload we want to reselect all rows which are currently selected,\n\t// if there is an rowId (i.e. a unique value to identify each row with)\n\tapi.on( 'preXhr.dt.dtSelect', function (e, settings) {\n\t\tif (settings !== api.settings()[0]) {\n\t\t\t// Not triggered by our DataTable!\n\t\t\treturn;\n\t\t}\n\n\t\t// note that column selection doesn't need to be cached and then\n\t\t// reselected, as they are already selected\n\t\tvar rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\tvar cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {\n\t\t\tvar id = api.row( cellIdx.row ).id( true );\n\t\t\treturn id ?\n\t\t\t\t{ row: id, column: cellIdx.column } :\n\t\t\t\tundefined;\n\t\t} ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\t// On the next draw, reselect the currently selected items\n\t\tapi.one( 'draw.dt.dtSelect', function () {\n\t\t\tapi.rows( rows ).select();\n\n\t\t\t// `cells` is not a cell index selector, so it needs a loop\n\t\t\tif ( cells.any() ) {\n\t\t\t\tcells.each( function ( id ) {\n\t\t\t\t\tapi.cells( id.row, id.column ).select();\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t} );\n\n\t// Update the table information element with selected item summary\n\tapi.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {\n\t\tinfo( api );\n\t\tapi.state.save();\n\t} );\n\n\t// Clean up and release\n\tapi.on( 'destroy.dtSelect', function () {\n\t\tapi.rows({selected: true}).deselect();\n\n\t\tdisableMouseSelection( api );\n\t\tapi.off( '.dtSelect' );\n\t\t$('body').off('.dtSelect' + _safeId(api.table().node()));\n\t} );\n}\n\n/**\n * Add one or more items (rows or columns) to the selection when shift clicking\n * in OS selection style\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {string}        type Row or column range selector\n * @param  {object}        idx  Item index to select to\n * @param  {object}        last Item index to select from\n * @private\n */\nfunction rowColumnRange( dt, type, idx, last )\n{\n\t// Add a range of rows from the last selected row to this one\n\tvar indexes = dt[type+'s']( { search: 'applied' } ).indexes();\n\tvar idx1 = $.inArray( last, indexes );\n\tvar idx2 = $.inArray( idx, indexes );\n\n\tif ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {\n\t\t// select from top to here - slightly odd, but both Windows and Mac OS\n\t\t// do this\n\t\tindexes.splice( $.inArray( idx, indexes )+1, indexes.length );\n\t}\n\telse {\n\t\t// reverse so we can shift click 'up' as well as down\n\t\tif ( idx1 > idx2 ) {\n\t\t\tvar tmp = idx2;\n\t\t\tidx2 = idx1;\n\t\t\tidx1 = tmp;\n\t\t}\n\n\t\tindexes.splice( idx2+1, indexes.length );\n\t\tindexes.splice( 0, idx1 );\n\t}\n\n\tif ( ! dt[type]( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt[type+'s']( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range - need to keep the clicked on row selected\n\t\tindexes.splice( $.inArray( idx, indexes ), 1 );\n\t\tdt[type+'s']( indexes ).deselect();\n\t}\n}\n\n/**\n * Clear all selected items\n *\n * @param  {DataTable.settings} ctx Settings object of the host DataTable\n * @param  {boolean} [force=false] Force the de-selection to happen, regardless\n *     of selection style\n * @private\n */\nfunction clear( ctx, force )\n{\n\tif ( force || ctx._select.style === 'single' ) {\n\t\tvar api = new DataTable.Api( ctx );\n\t\t\n\t\tapi.rows( { selected: true } ).deselect();\n\t\tapi.columns( { selected: true } ).deselect();\n\t\tapi.cells( { selected: true } ).deselect();\n\t}\n}\n\n/**\n * Select items based on the current configuration for style and items.\n *\n * @param  {object}             e    Mouse event object\n * @param  {DataTables.Api}     dt   DataTable\n * @param  {DataTable.settings} ctx  Settings object of the host DataTable\n * @param  {string}             type Items to select\n * @param  {int|object}         idx  Index of the item to select\n * @private\n */\nfunction typeSelect ( e, dt, ctx, type, idx )\n{\n\tvar style = dt.select.style();\n\tvar toggleable = dt.select.toggleable();\n\tvar isSelected = dt[type]( idx, { selected: true } ).any();\n\t\n\tif ( isSelected && ! toggleable ) {\n\t\treturn;\n\t}\n\n\tif ( style === 'os' ) {\n\t\tif ( e.ctrlKey || e.metaKey ) {\n\t\t\t// Add or remove from the selection\n\t\t\tdt[type]( idx ).select( ! isSelected );\n\t\t}\n\t\telse if ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No cmd or shift click - deselect if selected, or select\n\t\t\t// this row only\n\t\t\tvar selected = dt[type+'s']( { selected: true } );\n\n\t\t\tif ( isSelected && selected.flatten().length === 1 ) {\n\t\t\t\tdt[type]( idx ).deselect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselected.deselect();\n\t\t\t\tdt[type]( idx ).select();\n\t\t\t}\n\t\t}\n\t} else if ( style == 'multi+shift' ) {\n\t\tif ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdt[ type ]( idx ).select( ! isSelected );\n\t\t}\n\t}\n\telse {\n\t\tdt[ type ]( idx ).select( ! isSelected );\n\t}\n}\n\nfunction _safeId( node ) {\n\treturn node.id.replace(/[^a-zA-Z0-9\\-\\_]/g, '-');\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables selectors\n */\n\n// row and column are basically identical just assigned to different properties\n// and checking a different array, so we can dynamically create the functions to\n// reduce the code size\n$.each( [\n\t{ type: 'row', prop: 'aoData' },\n\t{ type: 'column', prop: 'aoColumns' }\n], function ( i, o ) {\n\tDataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {\n\t\tvar selected = opts.selected;\n\t\tvar data;\n\t\tvar out = [];\n\n\t\tif ( selected !== true && selected !== false ) {\n\t\t\treturn indexes;\n\t\t}\n\n\t\tfor ( var i=0, ien=indexes.length ; i<ien ; i++ ) {\n\t\t\tdata = settings[ o.prop ][ indexes[i] ];\n\n\t\t\tif ( (selected === true && data._select_selected === true) ||\n\t\t\t     (selected === false && ! data._select_selected )\n\t\t\t) {\n\t\t\t\tout.push( indexes[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t} );\n} );\n\nDataTable.ext.selector.cell.push( function ( settings, opts, cells ) {\n\tvar selected = opts.selected;\n\tvar rowData;\n\tvar out = [];\n\n\tif ( selected === undefined ) {\n\t\treturn cells;\n\t}\n\n\tfor ( var i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\trowData = settings.aoData[ cells[i].row ];\n\n\t\tif ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||\n\t\t     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )\n\t\t) {\n\t\t\tout.push( cells[i] );\n\t\t}\n\t}\n\n\treturn out;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Local variables to improve compression\nvar apiRegister = DataTable.Api.register;\nvar apiRegisterPlural = DataTable.Api.registerPlural;\n\napiRegister( 'select()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tDataTable.select.init( new DataTable.Api( ctx ) );\n\t} );\n} );\n\napiRegister( 'select.blurable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.blurable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.blurable = flag;\n\t} );\n} );\n\napiRegister( 'select.toggleable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.toggleable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.toggleable = flag;\n\t} );\n} );\n\napiRegister( 'select.info()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.info;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.info = flag;\n\t} );\n} );\n\napiRegister( 'select.items()', function ( items ) {\n\tif ( items === undefined ) {\n\t\treturn this.context[0]._select.items;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.items = items;\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );\n\t} );\n} );\n\n// Takes effect from the _next_ selection. None disables future selection, but\n// does not clear the current selection. Use the `deselect` methods for that\napiRegister( 'select.style()', function ( style ) {\n\tif ( style === undefined ) {\n\t\treturn this.context[0]._select.style;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ! ctx._select ) {\n\t\t\tDataTable.select.init( new DataTable.Api(ctx) );\n\t\t}\n\n\t\tif ( ! ctx._select_init ) {\n\t\t\tinit(ctx);\n\t\t}\n\n\t\tctx._select.style = style;\n\n\t\t// Add / remove mouse event handlers. They aren't required when only\n\t\t// API selection is available\n\t\tvar dt = new DataTable.Api( ctx );\n\t\tdisableMouseSelection( dt );\n\t\t\n\t\tif ( style !== 'api' ) {\n\t\t\tenableMouseSelection( dt );\n\t\t}\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );\n\t} );\n} );\n\napiRegister( 'select.selector()', function ( selector ) {\n\tif ( selector === undefined ) {\n\t\treturn this.context[0]._select.selector;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tdisableMouseSelection( new DataTable.Api( ctx ) );\n\n\t\tctx._select.selector = selector;\n\n\t\tif ( ctx._select.style !== 'api' ) {\n\t\t\tenableMouseSelection( new DataTable.Api( ctx ) );\n\t\t}\n\t} );\n} );\n\n\n\napiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoData[ idx ]._select_selected = true;\n\t\t$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'row().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoData[this[0]] &&\n\t\tctx.aoData[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoColumns[ idx ]._select_selected = true;\n\n\t\tvar column = new DataTable.Api( ctx ).column( idx );\n\n\t\t$( column.header() ).addClass( ctx._select.className );\n\t\t$( column.footer() ).addClass( ctx._select.className );\n\n\t\tcolumn.nodes().to$().addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'column().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoColumns[this[0]] &&\n\t\tctx.aoColumns[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tclear( ctx );\n\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif ( data._selected_cells === undefined ) {\n\t\t\tdata._selected_cells = [];\n\t\t}\n\n\t\tdata._selected_cells[ colIdx ] = true;\n\n\t\tif ( data.anCells ) {\n\t\t\t$( data.anCells[ colIdx ] ).addClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'cell', api.cells(api[i]).indexes().toArray() ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'cell().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length) {\n\t\tvar row = ctx.aoData[this[0][0].row];\n\n\t\tif (row && row._selected_cells && row._selected_cells[this[0][0].column]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n} );\n\n\napiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tctx.aoData[ idx ]._select_selected = false;\n\t\tctx._select_lastCell = null;\n\t\t$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tctx.aoColumns[ idx ]._select_selected = false;\n\n\t\tvar api = new DataTable.Api( ctx );\n\t\tvar column = api.column( idx );\n\n\t\t$( column.header() ).removeClass( ctx._select.className );\n\t\t$( column.footer() ).removeClass( ctx._select.className );\n\n\t\t// Need to loop over each cell, rather than just using\n\t\t// `column().nodes()` as cells which are individually selected should\n\t\t// not have the `selected` class removed from them\n\t\tapi.cells( null, idx ).indexes().each( function (cellIdx) {\n\t\t\tvar data = ctx.aoData[ cellIdx.row ];\n\t\t\tvar cellSelected = data._selected_cells;\n\n\t\t\tif ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {\n\t\t\t\t$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );\n\t\t\t}\n\t\t} );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif(data._selected_cells !== undefined) {\n\t\t\tdata._selected_cells[ colIdx ] = false;\n\t\t}\n\n\t\t// Remove class only if the cells exist, and the cell is not column\n\t\t// selected, in which case the class should remain (since it is selected\n\t\t// in the column)\n\t\tif ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {\n\t\t\t$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'cell', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\nfunction i18n( label, def ) {\n\treturn function (dt) {\n\t\treturn dt.i18n( 'buttons.'+label, def );\n\t};\n}\n\n// Common events with suitable namespaces\nfunction namespacedEvents ( config ) {\n\tvar unique = config._eventNamespace;\n\n\treturn 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;\n}\n\nfunction enabled ( dt, config ) {\n\tif ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar _buttonNamespace = 0;\n\n$.extend( DataTable.ext.buttons, {\n\tselected: {\n\t\ttext: i18n( 'selected', 'Selected' ),\n\t\tclassName: 'buttons-selected',\n\t\tlimitTo: [ 'rows', 'columns', 'cells' ],\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\t// .DT namespace listeners are removed by DataTables automatically\n\t\t\t// on table destroy\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tthat.enable( enabled(dt, config) );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectedSingle: {\n\t\ttext: i18n( 'selectedSingle', 'Selected single' ),\n\t\tclassName: 'buttons-selected-single',\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count === 1 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectAll: {\n\t\ttext: i18n( 'selectAll', 'Select all' ),\n\t\tclassName: 'buttons-select-all',\n\t\taction: function () {\n\t\t\tvar items = this.select.items();\n\t\t\tthis[ items+'s' ]().select();\n\t\t}\n\t},\n\tselectNone: {\n\t\ttext: i18n( 'selectNone', 'Deselect all' ),\n\t\tclassName: 'buttons-select-none',\n\t\taction: function () {\n\t\t\tclear( this.settings()[0], true );\n\t\t},\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count > 0 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t}\n} );\n\n$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {\n\tvar lc = item.toLowerCase();\n\n\tDataTable.ext.buttons[ 'select'+item+'s' ] = {\n\t\ttext: i18n( 'select'+item+'s', 'Select '+lc+'s' ),\n\t\tclassName: 'buttons-select-'+lc+'s',\n\t\taction: function () {\n\t\t\tthis.select.items( lc );\n\t\t},\n\t\tinit: function ( dt ) {\n\t\t\tvar that = this;\n\n\t\t\tdt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {\n\t\t\t\tthat.active( items === lc );\n\t\t\t} );\n\t\t}\n\t};\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n */\n\n// DataTables creation - check if select has been defined in the options. Note\n// this required that the table be in the document! If it isn't then something\n// needs to trigger this method unfortunately. The next major release of\n// DataTables will rework the events and address this.\n$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tDataTable.select.init( new DataTable.Api( ctx ) );\n} );\n\n\nreturn DataTable.select;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0LWJzNS9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0LmpzP2MwZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxFQUFFLGlDQUFRLENBQUMsMkNBQVEsRUFBRSwyREFBZ0IsQ0FBQyxtQ0FBRTtBQUN4QztBQUNBLEdBQUc7QUFBQSxvR0FBRTtBQUNMO0FBQ0EsTUFBTSxFQWlCSjtBQUNGLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxxQ0FBcUMsY0FBYztBQUNuRCxpQ0FBaUMsY0FBYztBQUMvQyxZQUFZO0FBQ1osSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQkFBMEIsb0JBQW9COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0MsNkJBQTZCLGlCQUFpQjtBQUM5QywyQkFBMkIsaUJBQWlCOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDhEQUE4RDtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0EsR0FBRzs7QUFFSCwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2QztBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFZLGVBQWU7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCLGdCQUFnQixpQkFBaUI7QUFDakMsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxlQUFlO0FBQzNCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksT0FBTztBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhCQUE4QjtBQUNoQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTs7QUFFQSxvRUFBb0UsaUJBQWlCO0FBQ3JGO0FBQ0E7O0FBRUEsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsNkJBQTZCLGlCQUFpQjtBQUM5QywyQkFBMkIsaUJBQWlCOztBQUU1QztBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyw2QkFBNkIsaUJBQWlCO0FBQzlDLDJCQUEyQixpQkFBaUI7O0FBRTVDO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXNlbGVjdC1iczUvbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXNlbGVjdC9qcy9kYXRhVGFibGVzLnNlbGVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBTZWxlY3QgZm9yIERhdGFUYWJsZXMgMS40LjAtZGV2XG4gKiAyMDE1LTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKi9cblxuLyoqXG4gKiBAc3VtbWFyeSAgICAgU2VsZWN0IGZvciBEYXRhVGFibGVzXG4gKiBAZGVzY3JpcHRpb24gQSBjb2xsZWN0aW9uIG9mIEFQSSBtZXRob2RzLCBldmVudHMgYW5kIGJ1dHRvbnMgZm9yIERhdGFUYWJsZXNcbiAqICAgdGhhdCBwcm92aWRlcyBzZWxlY3Rpb24gb3B0aW9ucyBvZiB0aGUgaXRlbXMgaW4gYSBEYXRhVGFibGVcbiAqIEB2ZXJzaW9uICAgICAxLjQuMC1kZXZcbiAqIEBmaWxlICAgICAgICBkYXRhVGFibGVzLnNlbGVjdC5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGQgKHd3dy5zcHJ5bWVkaWEuY28udWspXG4gKiBAY29udGFjdCAgICAgZGF0YXRhYmxlcy5uZXQvZm9ydW1zXG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMTUtMjAyMSBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZS9taXRcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxuICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIGxpY2Vuc2UgZmlsZXMgZm9yIGRldGFpbHMuXG4gKlxuICogRm9yIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvOiBodHRwOi8vd3d3LmRhdGF0YWJsZXMubmV0L2V4dGVuc2lvbnMvc2VsZWN0XG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcblx0XHRcdFx0JCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHJvb3QsIHJvb3QuZG9jdW1lbnQgKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufShmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xuXG5cbi8vIFZlcnNpb24gaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2VyXG5EYXRhVGFibGUuc2VsZWN0ID0ge307XG5cbkRhdGFUYWJsZS5zZWxlY3QudmVyc2lvbiA9ICcxLjQuMC1kZXYnO1xuXG5EYXRhVGFibGUuc2VsZWN0LmluaXQgPSBmdW5jdGlvbiAoIGR0ICkge1xuXHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblxuXHRpZiAoY3R4Ll9zZWxlY3QpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgc2F2ZWRTZWxlY3RlZCA9IGR0LnN0YXRlLmxvYWRlZCgpO1xuXG5cdHZhciBzZWxlY3RBbmRTYXZlID0gZnVuY3Rpb24oZSwgc2V0dGluZ3MsIGRhdGEpIHtcblx0XHRpZihkYXRhID09PSBudWxsIHx8IGRhdGEuc2VsZWN0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGVhciBhbnkgY3VycmVudGx5IHNlbGVjdGVkIHJvd3MsIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGVcblx0XHQvLyBOb25lIHdpbGwgYmUgc2VsZWN0ZWQgb24gZmlyc3QgaW5pdGlhbGlzYXRpb25cblx0XHRpZiAoZHQucm93cyh7c2VsZWN0ZWQ6IHRydWV9KS5hbnkoKSkge1xuXHRcdFx0ZHQucm93cygpLmRlc2VsZWN0KCk7XG5cdFx0fVxuXHRcdGlmIChkYXRhLnNlbGVjdC5yb3dzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGR0LnJvd3MoZGF0YS5zZWxlY3Qucm93cykuc2VsZWN0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGR0LmNvbHVtbnMoe3NlbGVjdGVkOiB0cnVlfSkuYW55KCkpIHtcblx0XHRcdGR0LmNvbHVtbnMoKS5kZXNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3QuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5jb2x1bW5zKGRhdGEuc2VsZWN0LmNvbHVtbnMpLnNlbGVjdCgpO1xuXHRcdH1cblxuXHRcdGlmIChkdC5jZWxscyh7c2VsZWN0ZWQ6IHRydWV9KS5hbnkoKSkge1xuXHRcdFx0ZHQuY2VsbHMoKS5kZXNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3QuY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRhdGEuc2VsZWN0LmNlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGR0LmNlbGwoZGF0YS5zZWxlY3QuY2VsbHNbaV0ucm93LCBkYXRhLnNlbGVjdC5jZWxsc1tpXS5jb2x1bW4pLnNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRkdC5zdGF0ZS5zYXZlKCk7XG5cdH1cblx0XG5cdGR0Lm9uZSgnaW5pdCcsIGZ1bmN0aW9uKCkge1xuXHRcdGR0Lm9uKCdzdGF0ZVNhdmVQYXJhbXMnLCBmdW5jdGlvbihlLCBzZXR0aW5ncywgZGF0YSkge1xuXHRcdFx0ZGF0YS5zZWxlY3QgPSB7fTtcblx0XHRcdGRhdGEuc2VsZWN0LnJvd3MgPSBkdC5yb3dzKHtzZWxlY3RlZDp0cnVlfSkuaWRzKHRydWUpLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEuc2VsZWN0LmNvbHVtbnMgPSBkdC5jb2x1bW5zKHtzZWxlY3RlZDp0cnVlfSlbMF07XG5cdFx0XHRkYXRhLnNlbGVjdC5jZWxscyA9IGR0LmNlbGxzKHtzZWxlY3RlZDp0cnVlfSlbMF0ubWFwKGZ1bmN0aW9uKGNvb3Jkcykge1xuXHRcdFx0XHRyZXR1cm4ge3JvdzogZHQucm93KGNvb3Jkcy5yb3cpLmlkKHRydWUpLCBjb2x1bW46IGNvb3Jkcy5jb2x1bW59XG5cdFx0XHR9KTtcblx0XHR9KVxuXHRcdFxuXHRcdHNlbGVjdEFuZFNhdmUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHNhdmVkU2VsZWN0ZWQpXG5cdFx0ZHQub24oJ3N0YXRlTG9hZGVkIHN0YXRlTG9hZFBhcmFtcycsIHNlbGVjdEFuZFNhdmUpXG5cdH0pXG5cblx0dmFyIGluaXQgPSBjdHgub0luaXQuc2VsZWN0O1xuXHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMuc2VsZWN0O1xuXHR2YXIgb3B0cyA9IGluaXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ZGVmYXVsdHMgOlxuXHRcdGluaXQ7XG5cblx0Ly8gU2V0IGRlZmF1bHRzXG5cdHZhciBpdGVtcyA9ICdyb3cnO1xuXHR2YXIgc3R5bGUgPSAnYXBpJztcblx0dmFyIGJsdXJhYmxlID0gZmFsc2U7XG5cdHZhciB0b2dnbGVhYmxlID0gdHJ1ZTtcblx0dmFyIGluZm8gPSB0cnVlO1xuXHR2YXIgc2VsZWN0b3IgPSAndGQsIHRoJztcblx0dmFyIGNsYXNzTmFtZSA9ICdzZWxlY3RlZCc7XG5cdHZhciBzZXRTdHlsZSA9IGZhbHNlO1xuXG5cdGN0eC5fc2VsZWN0ID0ge307XG5cblx0Ly8gSW5pdGlhbGlzYXRpb24gY3VzdG9taXNhdGlvbnNcblx0aWYgKCBvcHRzID09PSB0cnVlICkge1xuXHRcdHN0eWxlID0gJ29zJztcblx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJyApIHtcblx0XHRzdHlsZSA9IG9wdHM7XG5cdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIG9wdHMgKSApIHtcblx0XHRpZiAoIG9wdHMuYmx1cmFibGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGJsdXJhYmxlID0gb3B0cy5ibHVyYWJsZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBvcHRzLnRvZ2dsZWFibGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRvZ2dsZWFibGUgPSBvcHRzLnRvZ2dsZWFibGU7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLmluZm8gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGluZm8gPSBvcHRzLmluZm87XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLml0ZW1zICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpdGVtcyA9IG9wdHMuaXRlbXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLnN0eWxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdHlsZSA9IG9wdHMuc3R5bGU7XG5cdFx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3R5bGUgPSAnb3MnO1xuXHRcdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSBvcHRzLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNsYXNzTmFtZSA9IG9wdHMuY2xhc3NOYW1lO1xuXHRcdH1cblx0fVxuXG5cdGR0LnNlbGVjdC5zZWxlY3Rvciggc2VsZWN0b3IgKTtcblx0ZHQuc2VsZWN0Lml0ZW1zKCBpdGVtcyApO1xuXHRkdC5zZWxlY3Quc3R5bGUoIHN0eWxlICk7XG5cdGR0LnNlbGVjdC5ibHVyYWJsZSggYmx1cmFibGUgKTtcblx0ZHQuc2VsZWN0LnRvZ2dsZWFibGUoIHRvZ2dsZWFibGUgKTtcblx0ZHQuc2VsZWN0LmluZm8oIGluZm8gKTtcblx0Y3R4Ll9zZWxlY3QuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG5cblx0Ly8gU29ydCB0YWJsZSBiYXNlZCBvbiBzZWxlY3RlZCByb3dzLiBSZXF1aXJlcyBTZWxlY3QgRGF0YXRhYmxlcyBleHRlbnNpb25cblx0JC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyWydzZWxlY3QtY2hlY2tib3gnXSA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbCApIHtcblx0XHRyZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOiAnaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncy5fc2VsZWN0Lml0ZW1zID09PSAncm93JyApIHtcblx0XHRcdFx0cmV0dXJuICQoIHRkICkucGFyZW50KCkuaGFzQ2xhc3MoIHNldHRpbmdzLl9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZXR0aW5ncy5fc2VsZWN0Lml0ZW1zID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0ZCApLmhhc0NsYXNzKCBzZXR0aW5ncy5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8vIElmIHRoZSBpbml0IG9wdGlvbnMgaGF2ZW4ndCBlbmFibGVkIHNlbGVjdCwgYnV0IHRoZXJlIGlzIGEgc2VsZWN0YWJsZVxuXHQvLyBjbGFzcyBuYW1lLCB0aGVuIGVuYWJsZVxuXHRpZiAoICEgc2V0U3R5bGUgJiYgJCggZHQudGFibGUoKS5ub2RlKCkgKS5oYXNDbGFzcyggJ3NlbGVjdGFibGUnICkgKSB7XG5cdFx0ZHQuc2VsZWN0LnN0eWxlKCAnb3MnICk7XG5cdH1cbn07XG5cbi8qXG5cblNlbGVjdCBpcyBhIGNvbGxlY3Rpb24gb2YgQVBJIG1ldGhvZHMsIGV2ZW50IGhhbmRsZXJzLCBldmVudCBlbWl0dGVycyBhbmRcbmJ1dHRvbnMgKGZvciB0aGUgYEJ1dHRvbnNgIGV4dGVuc2lvbikgZm9yIERhdGFUYWJsZXMuIEl0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmdcbmZlYXR1cmVzLCB3aXRoIGFuIG92ZXJ2aWV3IG9mIGhvdyB0aGV5IGFyZSBpbXBsZW1lbnRlZDpcblxuIyMgU2VsZWN0aW9uIG9mIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzLiBXaGV0aGVyIGFuIGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90IGlzXG4gICBzdG9yZWQgaW46XG5cbiogcm93czogYSBgX3NlbGVjdF9zZWxlY3RlZGAgcHJvcGVydHkgd2hpY2ggY29udGFpbnMgYSBib29sZWFuIHZhbHVlIG9mIHRoZVxuICBEYXRhVGFibGVzJyBgYW9EYXRhYCBvYmplY3QgZm9yIGVhY2ggcm93XG4qIGNvbHVtbnM6IGEgYF9zZWxlY3Rfc2VsZWN0ZWRgIHByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGEgYm9vbGVhbiB2YWx1ZSBvZiB0aGVcbiAgRGF0YVRhYmxlcycgYGFvQ29sdW1uc2Agb2JqZWN0IGZvciBlYWNoIGNvbHVtblxuKiBjZWxsczogYSBgX3NlbGVjdGVkX2NlbGxzYCBwcm9wZXJ0eSB3aGljaCBjb250YWlucyBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlc1xuICBvZiB0aGUgYGFvRGF0YWAgb2JqZWN0IGZvciBlYWNoIHJvdy4gVGhlIGFycmF5IGlzIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcbiAgY29sdW1ucyBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgb2YgaXQgcmVwcmVzZW50aW5nIGEgY2VsbC5cblxuVGhpcyBtZXRob2Qgb2YgdXNpbmcgYm9vbGVhbiBmbGFncyBhbGxvd3MgU2VsZWN0IHRvIG9wZXJhdGUgd2hlbiBub2RlcyBoYXZlIG5vdFxuYmVlbiBjcmVhdGVkIGZvciByb3dzIC8gY2VsbHMgKERhdGFUYWJsZXMnIGRlZmVyIHJlbmRlcmluZyBmZWF0dXJlKS5cblxuIyMgQVBJIG1ldGhvZHNcblxuQSByYW5nZSBvZiBBUEkgbWV0aG9kcyBhcmUgYXZhaWxhYmxlIGZvciB0cmlnZ2VyaW5nIHNlbGVjdGlvbiBhbmQgZGUtc2VsZWN0aW9uXG5vZiByb3dzLiBNZXRob2RzIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBjb25maWd1cmUgdGhlIHNlbGVjdGlvbiBldmVudHMgdGhhdCBjYW5cbmJlIHRyaWdnZXJlZCBieSBhbiBlbmQgdXNlciAoc3VjaCBhcyB3aGljaCBpdGVtcyBhcmUgdG8gYmUgc2VsZWN0ZWQpLiBUbyBhIGxhcmdlXG5leHRlbnQsIHRoZXNlIG9mIEFQSSBtZXRob2RzICppcyogU2VsZWN0LiBJdCBpcyBiYXNpY2FsbHkgYSBjb2xsZWN0aW9uIG9mIGhlbHBlclxuZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IGl0ZW1zIGluIGEgRGF0YVRhYmxlLlxuXG5Db25maWd1cmF0aW9uIG9mIHNlbGVjdCBpcyBoZWxkIGluIHRoZSBvYmplY3QgYF9zZWxlY3RgIHdoaWNoIGlzIGF0dGFjaGVkIHRvIHRoZVxuRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qgb24gaW5pdGlhbGlzYXRpb24uIFNlbGVjdCBiZWluZyBhdmFpbGFibGUgb24gYSB0YWJsZVxuaXMgbm90IG9wdGlvbmFsIHdoZW4gU2VsZWN0IGlzIGxvYWRlZCwgYnV0IGl0cyBkZWZhdWx0IGlzIGZvciBzZWxlY3Rpb24gb25seSB0b1xuYmUgYXZhaWxhYmxlIHZpYSB0aGUgQVBJIC0gc28gdGhlIGVuZCB1c2VyIHdvdWxkbid0IGJlIGFibGUgdG8gc2VsZWN0IHJvd3NcbndpdGhvdXQgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLlxuXG5UaGUgYF9zZWxlY3RgIG9iamVjdCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbmBgYFxue1xuXHRpdGVtczpzdHJpbmcgICAgICAgLSBDYW4gYmUgYHJvd3NgLCBgY29sdW1uc2Agb3IgYGNlbGxzYC4gRGVmaW5lcyB3aGF0IGl0ZW0gXG5cdCAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBhY3RpdmF0ZSByb3dcblx0ICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uIHVzaW5nIHRoZSBtb3VzZS5cblx0c3R5bGU6c3RyaW5nICAgICAgIC0gQ2FuIGJlIGBub25lYCwgYHNpbmdsZWAsIGBtdWx0aWAgb3IgYG9zYC4gRGVmaW5lcyB0aGVcblx0ICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24gc3R5bGUgd2hlbiBzZWxlY3RpbmcgaXRlbXNcblx0Ymx1cmFibGU6Ym9vbGVhbiAgIC0gSWYgcm93IHNlbGVjdGlvbiBjYW4gYmUgY2xlYXJlZCBieSBjbGlja2luZyBvdXRzaWRlIG9mXG5cdCAgICAgICAgICAgICAgICAgICAgIHRoZSB0YWJsZVxuXHR0b2dnbGVhYmxlOmJvb2xlYW4gLSBJZiByb3cgc2VsZWN0aW9uIGNhbiBiZSBjYW5jZWxsZWQgYnkgcmVwZWF0ZWQgY2xpY2tpbmdcblx0ICAgICAgICAgICAgICAgICAgICAgb24gdGhlIHJvd1xuXHRpbmZvOmJvb2xlYW4gICAgICAgLSBJZiB0aGUgc2VsZWN0aW9uIHN1bW1hcnkgc2hvdWxkIGJlIHNob3duIGluIHRoZSB0YWJsZVxuXHQgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiBlbGVtZW50c1xufVxuYGBgXG5cbkluIGFkZGl0aW9uIHRvIHRoZSBBUEkgbWV0aG9kcywgU2VsZWN0IGFsc28gZXh0ZW5kcyB0aGUgRGF0YVRhYmxlcyBzZWxlY3Rvclxub3B0aW9ucyBmb3Igcm93cywgY29sdW1ucyBhbmQgY2VsbHMgYWRkaW5nIGEgYHNlbGVjdGVkYCBvcHRpb24gdG8gdGhlIHNlbGVjdG9yXG5vcHRpb25zIG9iamVjdCwgYWxsb3dpbmcgdGhlIGRldmVsb3BlciB0byBzZWxlY3Qgb25seSBzZWxlY3RlZCBpdGVtcyBvclxudW5zZWxlY3RlZCBpdGVtcy5cblxuIyMgTW91c2Ugc2VsZWN0aW9uIG9mIGl0ZW1zXG5cbkNsaWNraW5nIG9uIGl0ZW1zIGNhbiBiZSB1c2VkIHRvIHNlbGVjdCBpdGVtcy4gVGhpcyBpcyBkb25lIGJ5IGEgc2ltcGxlIGV2ZW50XG5oYW5kbGVyIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGl0ZW1zIHVzaW5nIHRoZSBBUEkgbWV0aG9kcy5cblxuICovXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIExvY2FsIGZ1bmN0aW9uc1xuICovXG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGNlbGxzIHRvIHRoZSBzZWxlY3Rpb24gd2hlbiBzaGlmdCBjbGlja2luZyBpbiBPUyBzZWxlY3Rpb25cbiAqIHN0eWxlIGNlbGwgc2VsZWN0aW9uLlxuICpcbiAqIENlbGwgcmFuZ2UgaXMgbW9yZSBjb21wbGljYXRlZCB0aGFuIHJvdyBhbmQgY29sdW1uIGFzIHdlIHdhbnQgdG8gc2VsZWN0XG4gKiBpbiB0aGUgdmlzaWJsZSBncmlkIHJhdGhlciB0aGFuIGJ5IGluZGV4IGluIHNlcXVlbmNlLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBjbGljayBmaXJzdCBpbiBjZWxsIDEtMSBhbmQgdGhlbiBzaGlmdCBjbGljayBpbiAyLTIgLSBjZWxscyAxLTIgYW5kIDItMVxuICogc2hvdWxkIGFsc28gYmUgc2VsZWN0ZWQgKGFuZCBub3QgMS0zLCAxLTQuIGV0YylcbiAqIFxuICogQHBhcmFtICB7RGF0YVRhYmxlLkFwaX0gZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGlkeCAgQ2VsbCBpbmRleCB0byBzZWxlY3QgdG9cbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGxhc3QgQ2VsbCBpbmRleCB0byBzZWxlY3QgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2VsbFJhbmdlKCBkdCwgaWR4LCBsYXN0IClcbntcblx0dmFyIGluZGV4ZXM7XG5cdHZhciBjb2x1bW5JbmRleGVzO1xuXHR2YXIgcm93SW5kZXhlcztcblx0dmFyIHNlbGVjdENvbHVtbnMgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0aWYgKCBzdGFydCA+IGVuZCApIHtcblx0XHRcdHZhciB0bXAgPSBlbmQ7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gdG1wO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgcmVjb3JkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGR0LmNvbHVtbnMoICc6dmlzaWJsZScgKS5pbmRleGVzKCkuZmlsdGVyKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0aWYgKCBpID09PSBzdGFydCApIHtcblx0XHRcdFx0cmVjb3JkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCBpID09PSBlbmQgKSB7IC8vIG5vdCBlbHNlIGlmLCBhcyBzdGFydCBtaWdodCA9PT0gZW5kXG5cdFx0XHRcdHJlY29yZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlY29yZDtcblx0XHR9ICk7XG5cdH07XG5cblx0dmFyIHNlbGVjdFJvd3MgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0dmFyIGluZGV4ZXMgPSBkdC5yb3dzKCB7IHNlYXJjaDogJ2FwcGxpZWQnIH0gKS5pbmRleGVzKCk7XG5cblx0XHQvLyBXaGljaCBjb21lcyBmaXJzdCAtIG1pZ2h0IG5lZWQgdG8gc3dhcFxuXHRcdGlmICggaW5kZXhlcy5pbmRleE9mKCBzdGFydCApID4gaW5kZXhlcy5pbmRleE9mKCBlbmQgKSApIHtcblx0XHRcdHZhciB0bXAgPSBlbmQ7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gdG1wO1xuXHRcdH1cblxuXHRcdHZhciByZWNvcmQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaW5kZXhlcy5maWx0ZXIoIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoIGkgPT09IHN0YXJ0ICkge1xuXHRcdFx0XHRyZWNvcmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIGkgPT09IGVuZCApIHtcblx0XHRcdFx0cmVjb3JkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVjb3JkO1xuXHRcdH0gKTtcblx0fTtcblxuXHRpZiAoICEgZHQuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICYmICEgbGFzdCApIHtcblx0XHQvLyBzZWxlY3QgZnJvbSB0aGUgdG9wIGxlZnQgY2VsbCB0byB0aGlzIG9uZVxuXHRcdGNvbHVtbkluZGV4ZXMgPSBzZWxlY3RDb2x1bW5zKCAwLCBpZHguY29sdW1uICk7XG5cdFx0cm93SW5kZXhlcyA9IHNlbGVjdFJvd3MoIDAgLCBpZHgucm93ICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2V0IGNvbHVtbiBpbmRleGVzIGJldHdlZW4gb2xkIGFuZCBuZXdcblx0XHRjb2x1bW5JbmRleGVzID0gc2VsZWN0Q29sdW1ucyggbGFzdC5jb2x1bW4sIGlkeC5jb2x1bW4gKTtcblx0XHRyb3dJbmRleGVzID0gc2VsZWN0Um93cyggbGFzdC5yb3cgLCBpZHgucm93ICk7XG5cdH1cblxuXHRpbmRleGVzID0gZHQuY2VsbHMoIHJvd0luZGV4ZXMsIGNvbHVtbkluZGV4ZXMgKS5mbGF0dGVuKCk7XG5cblx0aWYgKCAhIGR0LmNlbGxzKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICkge1xuXHRcdC8vIFNlbGVjdCByYW5nZVxuXHRcdGR0LmNlbGxzKCBpbmRleGVzICkuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2Vcblx0XHRkdC5jZWxscyggaW5kZXhlcyApLmRlc2VsZWN0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIG1vdXNlIHNlbGVjdGlvbiBieSByZW1vdmluZyB0aGUgc2VsZWN0b3JzXG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgdG8gcmVtb3ZlIGV2ZW50cyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNhYmxlTW91c2VTZWxlY3Rpb24oIGR0IClcbntcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdHZhciBzZWxlY3RvciA9IGN0eC5fc2VsZWN0LnNlbGVjdG9yO1xuXG5cdCQoIGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKVxuXHRcdC5vZmYoICdtb3VzZWRvd24uZHRTZWxlY3QnLCBzZWxlY3RvciApXG5cdFx0Lm9mZiggJ21vdXNldXAuZHRTZWxlY3QnLCBzZWxlY3RvciApXG5cdFx0Lm9mZiggJ2NsaWNrLmR0U2VsZWN0Jywgc2VsZWN0b3IgKTtcblxuXHQkKCdib2R5Jykub2ZmKCAnY2xpY2suZHRTZWxlY3QnICsgX3NhZmVJZChkdC50YWJsZSgpLm5vZGUoKSkgKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggbW91c2UgbGlzdGVuZXJzIHRvIHRoZSB0YWJsZSB0byBhbGxvdyBtb3VzZSBzZWxlY3Rpb24gb2YgaXRlbXNcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGR0IERhdGFUYWJsZSB0byByZW1vdmUgZXZlbnRzIGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZU1vdXNlU2VsZWN0aW9uICggZHQgKVxue1xuXHR2YXIgY29udGFpbmVyID0gJCggZHQudGFibGUoKS5jb250YWluZXIoKSApO1xuXHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0dmFyIHNlbGVjdG9yID0gY3R4Ll9zZWxlY3Quc2VsZWN0b3I7XG5cdHZhciBtYXRjaFNlbGVjdGlvbjtcblxuXHRjb250YWluZXJcblx0XHQub24oICdtb3VzZWRvd24uZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gRGlzYWxsb3cgdGV4dCBzZWxlY3Rpb24gZm9yIHNoaWZ0IGNsaWNraW5nIG9uIHRoZSB0YWJsZSBzbyBtdWx0aVxuXHRcdFx0Ly8gZWxlbWVudCBzZWxlY3Rpb24gZG9lc24ndCBsb29rIHRlcnJpYmxlIVxuXHRcdFx0aWYgKCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXkgKSB7XG5cdFx0XHRcdGNvbnRhaW5lclxuXHRcdFx0XHRcdC5jc3MoICctbW96LXVzZXItc2VsZWN0JywgJ25vbmUnIClcblx0XHRcdFx0XHQub25lKCdzZWxlY3RzdGFydC5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbmRvdy5nZXRTZWxlY3Rpb24gKSB7XG5cdFx0XHRcdG1hdGNoU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggJ21vdXNldXAuZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBBbGxvdyB0ZXh0IHNlbGVjdGlvbiB0byBvY2N1ciBhZ2FpbiwgTW96aWxsYSBzdHlsZSAodGVzdGVkIGluIEZGXG5cdFx0XHQvLyAzNS4wLjEgLSBzdGlsbCByZXF1aXJlZClcblx0XHRcdGNvbnRhaW5lci5jc3MoICctbW96LXVzZXItc2VsZWN0JywgJycgKTtcblx0XHR9IClcblx0XHQub24oICdjbGljay5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBkdC5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHZhciBpZHg7XG5cblx0XHRcdC8vIElmIHRleHQgd2FzIHNlbGVjdGVkIChjbGljayBhbmQgZHJhZyksIHRoZW4gd2Ugc2hvdWxkbid0IGNoYW5nZVxuXHRcdFx0Ly8gdGhlIHJvdydzIHNlbGVjdGVkIHN0YXRlXG5cdFx0XHRpZiAoIG1hdGNoU2VsZWN0aW9uICkge1xuXHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGlvbiBpcyBub3QgaW4gdGhlIHRhYmxlLCB3ZSBjYW4gaWdub3JlIGl0XG5cdFx0XHRcdC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgZGV2ZWxvcGVyIHNlbGVjdHMgdGV4dCBmcm9tIHRoZSBjbGljayBldmVudFxuXHRcdFx0XHRpZiAoICEgc2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgJChzZWxlY3Rpb24uYW5jaG9yTm9kZSkuY2xvc2VzdCgndGFibGUnKVswXSA9PT0gZHQudGFibGUoKS5ub2RlKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3Rpb24gIT09IG1hdGNoU2VsZWN0aW9uICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciB3cmFwcGVyQ2xhc3MgPSBkdC5zZXR0aW5ncygpWzBdLm9DbGFzc2VzLnNXcmFwcGVyLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnLicpO1xuXG5cdFx0XHQvLyBJZ25vcmUgY2xpY2tzIGluc2lkZSBhIHN1Yi10YWJsZVxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5jbG9zZXN0KCdkaXYuJyt3cmFwcGVyQ2xhc3MpWzBdICE9IGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNlbGwgPSBkdC5jZWxsKCAkKGUudGFyZ2V0KS5jbG9zZXN0KCd0ZCwgdGgnKSApO1xuXG5cdFx0XHQvLyBDaGVjayB0aGUgY2VsbCBhY3R1YWxseSBiZWxvbmdzIHRvIHRoZSBob3N0IERhdGFUYWJsZSAoc28gY2hpbGRcblx0XHRcdC8vIHJvd3MsIGV0YywgYXJlIGlnbm9yZWQpXG5cdFx0XHRpZiAoICEgY2VsbC5hbnkoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCd1c2VyLXNlbGVjdC5kdCcpO1xuXHRcdFx0ZXZlbnRUcmlnZ2VyKCBkdCwgZXZlbnQsIFsgaXRlbXMsIGNlbGwsIGUgXSApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjZWxsSW5kZXggPSBjZWxsLmluZGV4KCk7XG5cdFx0XHRpZiAoIGl0ZW1zID09PSAncm93JyApIHtcblx0XHRcdFx0aWR4ID0gY2VsbEluZGV4LnJvdztcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ3JvdycsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGl0ZW1zID09PSAnY29sdW1uJyApIHtcblx0XHRcdFx0aWR4ID0gY2VsbC5pbmRleCgpLmNvbHVtbjtcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ2NvbHVtbicsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGl0ZW1zID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdGlkeCA9IGNlbGwuaW5kZXgoKTtcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ2NlbGwnLCBpZHggKTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4Ll9zZWxlY3RfbGFzdENlbGwgPSBjZWxsSW5kZXg7XG5cdFx0fSApO1xuXG5cdC8vIEJsdXJhYmxlXG5cdCQoJ2JvZHknKS5vbiggJ2NsaWNrLmR0U2VsZWN0JyArIF9zYWZlSWQoZHQudGFibGUoKS5ub2RlKCkpLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0aWYgKCBjdHguX3NlbGVjdC5ibHVyYWJsZSApIHtcblx0XHRcdC8vIElmIHRoZSBjbGljayB3YXMgaW5zaWRlIHRoZSBEYXRhVGFibGVzIGNvbnRhaW5lciwgZG9uJ3QgYmx1clxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5wYXJlbnRzKCkuZmlsdGVyKCBkdC50YWJsZSgpLmNvbnRhaW5lcigpICkubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElnbm9yZSBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBET00gKGkuZS4gcGFnaW5nXG5cdFx0XHQvLyBidXR0b25zKVxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5wYXJlbnRzKCdodG1sJykubGVuZ3RoID09PSAwICkge1xuXHRcdFx0IFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEb24ndCBibHVyIGluIEVkaXRvciBmb3JtXG5cdFx0XHRpZiAoICQoZS50YXJnZXQpLnBhcmVudHMoJ2Rpdi5EVEUnKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCgnc2VsZWN0LWJsdXIuZHQnKTtcblx0XHRcdGV2ZW50VHJpZ2dlciggZHQsIGV2ZW50LCBbIGUudGFyZ2V0LCBlIF0gKTtcblxuXHRcdFx0aWYgKCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGVhciggY3R4LCB0cnVlICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBvbiBhIERhdGFUYWJsZVxuICpcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gYXBpICAgICAgRGF0YVRhYmxlIHRvIHRyaWdnZXIgZXZlbnRzIG9uXG4gKiBAcGFyYW0gIHtib29sZWFufSAgICAgIHNlbGVjdGVkIHRydWUgaWYgc2VsZWN0ZWQsIGZhbHNlIGlmIGRlc2VsZWN0ZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgdHlwZSAgICAgSXRlbSB0eXBlIGFjdGluZyBvblxuICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBhbnkgICAgICBSZXF1aXJlIHRoYXQgdGhlcmUgYXJlIHZhbHVlcyBiZWZvcmVcbiAqICAgICB0cmlnZ2VyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFRyaWdnZXIgKCBhcGksIHR5cGUsIGFyZ3MsIGFueSApXG57XG5cdGlmICggYW55ICYmICEgYXBpLmZsYXR0ZW4oKS5sZW5ndGggKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0dHlwZSA9IHR5cGUgKycuZHQnO1xuXHR9XG5cblx0YXJncy51bnNoaWZ0KCBhcGkgKTtcblxuXHQkKGFwaS50YWJsZSgpLm5vZGUoKSkudHJpZ2dlciggdHlwZSwgYXJncyApO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBvZiB0aGUgRGF0YVRhYmxlIHNob3dpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBpdGVtcyBzZWxlY3RlZC4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZyB0YWdzIHRvIHRoZSBleGlzdGluZyB0ZXh0XG4gKiBcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gYXBpIERhdGFUYWJsZSB0byB1cGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZm8gKCBhcGkgKVxue1xuXHR2YXIgY3R4ID0gYXBpLnNldHRpbmdzKClbMF07XG5cblx0aWYgKCAhIGN0eC5fc2VsZWN0LmluZm8gfHwgISBjdHguYWFuRmVhdHVyZXMuaSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIGFwaS5zZWxlY3Quc3R5bGUoKSA9PT0gJ2FwaScgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJvd3MgICAgPSBhcGkucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblx0dmFyIGNvbHVtbnMgPSBhcGkuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblx0dmFyIGNlbGxzICAgPSBhcGkuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cblx0dmFyIGFkZCA9IGZ1bmN0aW9uICggZWwsIG5hbWUsIG51bSApIHtcblx0XHRlbC5hcHBlbmQoICQoJzxzcGFuIGNsYXNzPVwic2VsZWN0LWl0ZW1cIi8+JykuYXBwZW5kKCBhcGkuaTE4bihcblx0XHRcdCdzZWxlY3QuJytuYW1lKydzJyxcblx0XHRcdHsgXzogJyVkICcrbmFtZSsncyBzZWxlY3RlZCcsIDA6ICcnLCAxOiAnMSAnK25hbWUrJyBzZWxlY3RlZCcgfSxcblx0XHRcdG51bVxuXHRcdCkgKSApO1xuXHR9O1xuXG5cdC8vIEludGVybmFsIGtub3dsZWRnZSBvZiBEYXRhVGFibGVzIHRvIGxvb3Agb3ZlciBhbGwgaW5mb3JtYXRpb24gZWxlbWVudHNcblx0JC5lYWNoKCBjdHguYWFuRmVhdHVyZXMuaSwgZnVuY3Rpb24gKCBpLCBlbCApIHtcblx0XHRlbCA9ICQoZWwpO1xuXG5cdFx0dmFyIG91dHB1dCAgPSAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pbmZvXCIvPicpO1xuXHRcdGFkZCggb3V0cHV0LCAncm93Jywgcm93cyApO1xuXHRcdGFkZCggb3V0cHV0LCAnY29sdW1uJywgY29sdW1ucyApO1xuXHRcdGFkZCggb3V0cHV0LCAnY2VsbCcsIGNlbGxzICApO1xuXG5cdFx0dmFyIGV4aXNpdGluZyA9IGVsLmNoaWxkcmVuKCdzcGFuLnNlbGVjdC1pbmZvJyk7XG5cdFx0aWYgKCBleGlzaXRpbmcubGVuZ3RoICkge1xuXHRcdFx0ZXhpc2l0aW5nLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGlmICggb3V0cHV0LnRleHQoKSAhPT0gJycgKSB7XG5cdFx0XHRlbC5hcHBlbmQoIG91dHB1dCApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIEluaXRpYWxpc2F0aW9uIG9mIGEgbmV3IHRhYmxlLiBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgYW5kIGNhbGxiYWNrcyB0byBhbGxvd1xuICogU2VsZWN0IHRvIG9wZXJhdGUgY29ycmVjdGx5LlxuICpcbiAqIFRoaXMgd2lsbCBvY2N1ciBfYWZ0ZXJfIHRoZSBpbml0aWFsIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb24sIGFsdGhvdWdoXG4gKiBiZWZvcmUgQWpheCBkYXRhIGlzIHJlbmRlcmVkLCBpZiB0aGVyZSBpcyBhamF4IGRhdGFcbiAqXG4gKiBAcGFyYW0gIHtEYXRhVGFibGUuc2V0dGluZ3N9IGN0eCBTZXR0aW5ncyBvYmplY3QgdG8gb3BlcmF0ZSBvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdCAoIGN0eCApIHtcblx0dmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblx0Y3R4Ll9zZWxlY3RfaW5pdCA9IHRydWU7XG5cblx0Ly8gUm93IGNhbGxiYWNrIHNvIHRoYXQgY2xhc3NlcyBjYW4gYmUgYWRkZWQgdG8gcm93cyBhbmQgY2VsbHMgaWYgdGhlIGl0ZW1cblx0Ly8gd2FzIHNlbGVjdGVkIGJlZm9yZSB0aGUgZWxlbWVudCB3YXMgY3JlYXRlZC4gVGhpcyB3aWxsIGhhcHBlbiB3aXRoIHRoZVxuXHQvLyBgZGVmZXJSZW5kZXJgIG9wdGlvbiBlbmFibGVkLlxuXHQvLyBcblx0Ly8gVGhpcyBtZXRob2Qgb2YgYXR0YWNoaW5nIHRvIGBhb1Jvd0NyZWF0ZWRDYWxsYmFja2AgaXMgYSBoYWNrIHVudGlsXG5cdC8vIERhdGFUYWJsZXMgaGFzIHByb3BlciBldmVudHMgZm9yIHJvdyBtYW5pcHVsYXRpb24gSWYgeW91IGFyZSByZXZpZXdpbmdcblx0Ly8gdGhpcyBjb2RlIHRvIGNyZWF0ZSB5b3VyIG93biBwbHVnLWlucywgcGxlYXNlIGRvIG5vdCBkbyB0aGlzIVxuXHRjdHguYW9Sb3dDcmVhdGVkQ2FsbGJhY2sucHVzaCgge1xuXHRcdGZuOiBmdW5jdGlvbiAoIHJvdywgZGF0YSwgaW5kZXggKSB7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcdFx0dmFyIGQgPSBjdHguYW9EYXRhWyBpbmRleCBdO1xuXG5cdFx0XHQvLyBSb3dcblx0XHRcdGlmICggZC5fc2VsZWN0X3NlbGVjdGVkICkge1xuXHRcdFx0XHQkKCByb3cgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbGxzIGFuZCBjb2x1bW5zIC0gaWYgc2VwYXJhdGVkIG91dCwgd2Ugd291bGQgbmVlZCB0byBkbyB0d29cblx0XHRcdC8vIGxvb3BzLCBzbyBpdCBtYWtlcyBzZW5zZSB0byBjb21iaW5lIHRoZW0gaW50byBhIHNpbmdsZSBvbmVcblx0XHRcdGZvciAoIGk9MCwgaWVuPWN0eC5hb0NvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY3R4LmFvQ29sdW1uc1tpXS5fc2VsZWN0X3NlbGVjdGVkIHx8IChkLl9zZWxlY3RlZF9jZWxscyAmJiBkLl9zZWxlY3RlZF9jZWxsc1tpXSkgKSB7XG5cdFx0XHRcdFx0JChkLmFuQ2VsbHNbaV0pLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c05hbWU6ICdzZWxlY3QtZGVmZXJSZW5kZXInXG5cdH0gKTtcblxuXHQvLyBPbiBBamF4IHJlbG9hZCB3ZSB3YW50IHRvIHJlc2VsZWN0IGFsbCByb3dzIHdoaWNoIGFyZSBjdXJyZW50bHkgc2VsZWN0ZWQsXG5cdC8vIGlmIHRoZXJlIGlzIGFuIHJvd0lkIChpLmUuIGEgdW5pcXVlIHZhbHVlIHRvIGlkZW50aWZ5IGVhY2ggcm93IHdpdGgpXG5cdGFwaS5vbiggJ3ByZVhoci5kdC5kdFNlbGVjdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncykge1xuXHRcdGlmIChzZXR0aW5ncyAhPT0gYXBpLnNldHRpbmdzKClbMF0pIHtcblx0XHRcdC8vIE5vdCB0cmlnZ2VyZWQgYnkgb3VyIERhdGFUYWJsZSFcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBub3RlIHRoYXQgY29sdW1uIHNlbGVjdGlvbiBkb2Vzbid0IG5lZWQgdG8gYmUgY2FjaGVkIGFuZCB0aGVuXG5cdFx0Ly8gcmVzZWxlY3RlZCwgYXMgdGhleSBhcmUgYWxyZWFkeSBzZWxlY3RlZFxuXHRcdHZhciByb3dzID0gYXBpLnJvd3MoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmlkcyggdHJ1ZSApLmZpbHRlciggZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIGQgIT09IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHR2YXIgY2VsbHMgPSBhcGkuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmVxKDApLm1hcCggZnVuY3Rpb24gKCBjZWxsSWR4ICkge1xuXHRcdFx0dmFyIGlkID0gYXBpLnJvdyggY2VsbElkeC5yb3cgKS5pZCggdHJ1ZSApO1xuXHRcdFx0cmV0dXJuIGlkID9cblx0XHRcdFx0eyByb3c6IGlkLCBjb2x1bW46IGNlbGxJZHguY29sdW1uIH0gOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSApLmZpbHRlciggZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIGQgIT09IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBPbiB0aGUgbmV4dCBkcmF3LCByZXNlbGVjdCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG5cdFx0YXBpLm9uZSggJ2RyYXcuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRhcGkucm93cyggcm93cyApLnNlbGVjdCgpO1xuXG5cdFx0XHQvLyBgY2VsbHNgIGlzIG5vdCBhIGNlbGwgaW5kZXggc2VsZWN0b3IsIHNvIGl0IG5lZWRzIGEgbG9vcFxuXHRcdFx0aWYgKCBjZWxscy5hbnkoKSApIHtcblx0XHRcdFx0Y2VsbHMuZWFjaCggZnVuY3Rpb24gKCBpZCApIHtcblx0XHRcdFx0XHRhcGkuY2VsbHMoIGlkLnJvdywgaWQuY29sdW1uICkuc2VsZWN0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHQvLyBVcGRhdGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnQgd2l0aCBzZWxlY3RlZCBpdGVtIHN1bW1hcnlcblx0YXBpLm9uKCAnZHJhdy5kdFNlbGVjdC5kdCBzZWxlY3QuZHRTZWxlY3QuZHQgZGVzZWxlY3QuZHRTZWxlY3QuZHQgaW5mby5kdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRpbmZvKCBhcGkgKTtcblx0XHRhcGkuc3RhdGUuc2F2ZSgpO1xuXHR9ICk7XG5cblx0Ly8gQ2xlYW4gdXAgYW5kIHJlbGVhc2Vcblx0YXBpLm9uKCAnZGVzdHJveS5kdFNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRhcGkucm93cyh7c2VsZWN0ZWQ6IHRydWV9KS5kZXNlbGVjdCgpO1xuXG5cdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKCBhcGkgKTtcblx0XHRhcGkub2ZmKCAnLmR0U2VsZWN0JyApO1xuXHRcdCQoJ2JvZHknKS5vZmYoJy5kdFNlbGVjdCcgKyBfc2FmZUlkKGFwaS50YWJsZSgpLm5vZGUoKSkpO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGl0ZW1zIChyb3dzIG9yIGNvbHVtbnMpIHRvIHRoZSBzZWxlY3Rpb24gd2hlbiBzaGlmdCBjbGlja2luZ1xuICogaW4gT1Mgc2VsZWN0aW9uIHN0eWxlXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLkFwaX0gZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgIHR5cGUgUm93IG9yIGNvbHVtbiByYW5nZSBzZWxlY3RvclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgaWR4ICBJdGVtIGluZGV4IHRvIHNlbGVjdCB0b1xuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgbGFzdCBJdGVtIGluZGV4IHRvIHNlbGVjdCBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByb3dDb2x1bW5SYW5nZSggZHQsIHR5cGUsIGlkeCwgbGFzdCApXG57XG5cdC8vIEFkZCBhIHJhbmdlIG9mIHJvd3MgZnJvbSB0aGUgbGFzdCBzZWxlY3RlZCByb3cgdG8gdGhpcyBvbmVcblx0dmFyIGluZGV4ZXMgPSBkdFt0eXBlKydzJ10oIHsgc2VhcmNoOiAnYXBwbGllZCcgfSApLmluZGV4ZXMoKTtcblx0dmFyIGlkeDEgPSAkLmluQXJyYXkoIGxhc3QsIGluZGV4ZXMgKTtcblx0dmFyIGlkeDIgPSAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApO1xuXG5cdGlmICggISBkdFt0eXBlKydzJ10oIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICYmIGlkeDEgPT09IC0xICkge1xuXHRcdC8vIHNlbGVjdCBmcm9tIHRvcCB0byBoZXJlIC0gc2xpZ2h0bHkgb2RkLCBidXQgYm90aCBXaW5kb3dzIGFuZCBNYWMgT1Ncblx0XHQvLyBkbyB0aGlzXG5cdFx0aW5kZXhlcy5zcGxpY2UoICQuaW5BcnJheSggaWR4LCBpbmRleGVzICkrMSwgaW5kZXhlcy5sZW5ndGggKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyByZXZlcnNlIHNvIHdlIGNhbiBzaGlmdCBjbGljayAndXAnIGFzIHdlbGwgYXMgZG93blxuXHRcdGlmICggaWR4MSA+IGlkeDIgKSB7XG5cdFx0XHR2YXIgdG1wID0gaWR4Mjtcblx0XHRcdGlkeDIgPSBpZHgxO1xuXHRcdFx0aWR4MSA9IHRtcDtcblx0XHR9XG5cblx0XHRpbmRleGVzLnNwbGljZSggaWR4MisxLCBpbmRleGVzLmxlbmd0aCApO1xuXHRcdGluZGV4ZXMuc3BsaWNlKCAwLCBpZHgxICk7XG5cdH1cblxuXHRpZiAoICEgZHRbdHlwZV0oIGlkeCwgeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0Ly8gU2VsZWN0IHJhbmdlXG5cdFx0ZHRbdHlwZSsncyddKCBpbmRleGVzICkuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2UgLSBuZWVkIHRvIGtlZXAgdGhlIGNsaWNrZWQgb24gcm93IHNlbGVjdGVkXG5cdFx0aW5kZXhlcy5zcGxpY2UoICQuaW5BcnJheSggaWR4LCBpbmRleGVzICksIDEgKTtcblx0XHRkdFt0eXBlKydzJ10oIGluZGV4ZXMgKS5kZXNlbGVjdCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIHNlbGVjdGVkIGl0ZW1zXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggU2V0dGluZ3Mgb2JqZWN0IG9mIHRoZSBob3N0IERhdGFUYWJsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBGb3JjZSB0aGUgZGUtc2VsZWN0aW9uIHRvIGhhcHBlbiwgcmVnYXJkbGVzc1xuICogICAgIG9mIHNlbGVjdGlvbiBzdHlsZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXIoIGN0eCwgZm9yY2UgKVxue1xuXHRpZiAoIGZvcmNlIHx8IGN0eC5fc2VsZWN0LnN0eWxlID09PSAnc2luZ2xlJyApIHtcblx0XHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdFxuXHRcdGFwaS5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5kZXNlbGVjdCgpO1xuXHRcdGFwaS5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5kZXNlbGVjdCgpO1xuXHRcdGFwaS5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIFNlbGVjdCBpdGVtcyBiYXNlZCBvbiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciBzdHlsZSBhbmQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICBlICAgIE1vdXNlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtICB7RGF0YVRhYmxlcy5BcGl9ICAgICBkdCAgIERhdGFUYWJsZVxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggIFNldHRpbmdzIG9iamVjdCBvZiB0aGUgaG9zdCBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgdHlwZSBJdGVtcyB0byBzZWxlY3RcbiAqIEBwYXJhbSAge2ludHxvYmplY3R9ICAgICAgICAgaWR4ICBJbmRleCBvZiB0aGUgaXRlbSB0byBzZWxlY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHR5cGVTZWxlY3QgKCBlLCBkdCwgY3R4LCB0eXBlLCBpZHggKVxue1xuXHR2YXIgc3R5bGUgPSBkdC5zZWxlY3Quc3R5bGUoKTtcblx0dmFyIHRvZ2dsZWFibGUgPSBkdC5zZWxlY3QudG9nZ2xlYWJsZSgpO1xuXHR2YXIgaXNTZWxlY3RlZCA9IGR0W3R5cGVdKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpO1xuXHRcblx0aWYgKCBpc1NlbGVjdGVkICYmICEgdG9nZ2xlYWJsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIHN0eWxlID09PSAnb3MnICkge1xuXHRcdGlmICggZS5jdHJsS2V5IHx8IGUubWV0YUtleSApIHtcblx0XHRcdC8vIEFkZCBvciByZW1vdmUgZnJvbSB0aGUgc2VsZWN0aW9uXG5cdFx0XHRkdFt0eXBlXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0Y2VsbFJhbmdlKCBkdCwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCB8fCBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsID9cblx0XHRcdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbFt0eXBlXSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5vIGNtZCBvciBzaGlmdCBjbGljayAtIGRlc2VsZWN0IGlmIHNlbGVjdGVkLCBvciBzZWxlY3Rcblx0XHRcdC8vIHRoaXMgcm93IG9ubHlcblx0XHRcdHZhciBzZWxlY3RlZCA9IGR0W3R5cGUrJ3MnXSggeyBzZWxlY3RlZDogdHJ1ZSB9ICk7XG5cblx0XHRcdGlmICggaXNTZWxlY3RlZCAmJiBzZWxlY3RlZC5mbGF0dGVuKCkubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRkdFt0eXBlXSggaWR4ICkuZGVzZWxlY3QoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWxlY3RlZC5kZXNlbGVjdCgpO1xuXHRcdFx0XHRkdFt0eXBlXSggaWR4ICkuc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBzdHlsZSA9PSAnbXVsdGkrc2hpZnQnICkge1xuXHRcdGlmICggZS5zaGlmdEtleSApIHtcblx0XHRcdGlmICggdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRjZWxsUmFuZ2UoIGR0LCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsIHx8IG51bGwgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3dDb2x1bW5SYW5nZSggZHQsIHR5cGUsIGlkeCwgY3R4Ll9zZWxlY3RfbGFzdENlbGwgP1xuXHRcdFx0XHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsW3R5cGVdIDpcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZHRbIHR5cGUgXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZHRbIHR5cGUgXSggaWR4ICkuc2VsZWN0KCAhIGlzU2VsZWN0ZWQgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBfc2FmZUlkKCBub2RlICkge1xuXHRyZXR1cm4gbm9kZS5pZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLVxcX10vZywgJy0nKTtcbn1cblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIHNlbGVjdG9yc1xuICovXG5cbi8vIHJvdyBhbmQgY29sdW1uIGFyZSBiYXNpY2FsbHkgaWRlbnRpY2FsIGp1c3QgYXNzaWduZWQgdG8gZGlmZmVyZW50IHByb3BlcnRpZXNcbi8vIGFuZCBjaGVja2luZyBhIGRpZmZlcmVudCBhcnJheSwgc28gd2UgY2FuIGR5bmFtaWNhbGx5IGNyZWF0ZSB0aGUgZnVuY3Rpb25zIHRvXG4vLyByZWR1Y2UgdGhlIGNvZGUgc2l6ZVxuJC5lYWNoKCBbXG5cdHsgdHlwZTogJ3JvdycsIHByb3A6ICdhb0RhdGEnIH0sXG5cdHsgdHlwZTogJ2NvbHVtbicsIHByb3A6ICdhb0NvbHVtbnMnIH1cbl0sIGZ1bmN0aW9uICggaSwgbyApIHtcblx0RGF0YVRhYmxlLmV4dC5zZWxlY3Rvclsgby50eXBlIF0ucHVzaCggZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cywgaW5kZXhlcyApIHtcblx0XHR2YXIgc2VsZWN0ZWQgPSBvcHRzLnNlbGVjdGVkO1xuXHRcdHZhciBkYXRhO1xuXHRcdHZhciBvdXQgPSBbXTtcblxuXHRcdGlmICggc2VsZWN0ZWQgIT09IHRydWUgJiYgc2VsZWN0ZWQgIT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGluZGV4ZXM7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluZGV4ZXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRkYXRhID0gc2V0dGluZ3NbIG8ucHJvcCBdWyBpbmRleGVzW2ldIF07XG5cblx0XHRcdGlmICggKHNlbGVjdGVkID09PSB0cnVlICYmIGRhdGEuX3NlbGVjdF9zZWxlY3RlZCA9PT0gdHJ1ZSkgfHxcblx0XHRcdCAgICAgKHNlbGVjdGVkID09PSBmYWxzZSAmJiAhIGRhdGEuX3NlbGVjdF9zZWxlY3RlZCApXG5cdFx0XHQpIHtcblx0XHRcdFx0b3V0LnB1c2goIGluZGV4ZXNbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9ICk7XG59ICk7XG5cbkRhdGFUYWJsZS5leHQuc2VsZWN0b3IuY2VsbC5wdXNoKCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzLCBjZWxscyApIHtcblx0dmFyIHNlbGVjdGVkID0gb3B0cy5zZWxlY3RlZDtcblx0dmFyIHJvd0RhdGE7XG5cdHZhciBvdXQgPSBbXTtcblxuXHRpZiAoIHNlbGVjdGVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIGNlbGxzO1xuXHR9XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIGNlbGxzW2ldLnJvdyBdO1xuXG5cdFx0aWYgKCAoc2VsZWN0ZWQgPT09IHRydWUgJiYgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHMgJiYgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNlbGxzW2ldLmNvbHVtbiBdID09PSB0cnVlKSB8fFxuXHRcdCAgICAgKHNlbGVjdGVkID09PSBmYWxzZSAmJiAoICEgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHMgfHwgISByb3dEYXRhLl9zZWxlY3RlZF9jZWxsc1sgY2VsbHNbaV0uY29sdW1uIF0gKSApXG5cdFx0KSB7XG5cdFx0XHRvdXQucHVzaCggY2VsbHNbaV0gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIERhdGFUYWJsZXMgQVBJXG4gKlxuICogRm9yIGNvbXBsZXRlIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9hcGkgZGlyZWN0b3J5IG9yIHRoZVxuICogRGF0YVRhYmxlcyBzaXRlXG4gKi9cblxuLy8gTG9jYWwgdmFyaWFibGVzIHRvIGltcHJvdmUgY29tcHJlc3Npb25cbnZhciBhcGlSZWdpc3RlciA9IERhdGFUYWJsZS5BcGkucmVnaXN0ZXI7XG52YXIgYXBpUmVnaXN0ZXJQbHVyYWwgPSBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5ibHVyYWJsZSgpJywgZnVuY3Rpb24gKCBmbGFnICkge1xuXHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuYmx1cmFibGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuYmx1cmFibGUgPSBmbGFnO1xuXHR9ICk7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LnRvZ2dsZWFibGUoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnRvZ2dsZWFibGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QudG9nZ2xlYWJsZSA9IGZsYWc7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuaW5mbygpJywgZnVuY3Rpb24gKCBmbGFnICkge1xuXHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuaW5mbztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRjdHguX3NlbGVjdC5pbmZvID0gZmxhZztcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5pdGVtcygpJywgZnVuY3Rpb24gKCBpdGVtcyApIHtcblx0aWYgKCBpdGVtcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5pdGVtcztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRjdHguX3NlbGVjdC5pdGVtcyA9IGl0ZW1zO1xuXG5cdFx0ZXZlbnRUcmlnZ2VyKCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICksICdzZWxlY3RJdGVtcycsIFsgaXRlbXMgXSApO1xuXHR9ICk7XG59ICk7XG5cbi8vIFRha2VzIGVmZmVjdCBmcm9tIHRoZSBfbmV4dF8gc2VsZWN0aW9uLiBOb25lIGRpc2FibGVzIGZ1dHVyZSBzZWxlY3Rpb24sIGJ1dFxuLy8gZG9lcyBub3QgY2xlYXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBVc2UgdGhlIGBkZXNlbGVjdGAgbWV0aG9kcyBmb3IgdGhhdFxuYXBpUmVnaXN0ZXIoICdzZWxlY3Quc3R5bGUoKScsIGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cdGlmICggc3R5bGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3Quc3R5bGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0aWYgKCAhIGN0eC5fc2VsZWN0ICkge1xuXHRcdFx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaShjdHgpICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIGN0eC5fc2VsZWN0X2luaXQgKSB7XG5cdFx0XHRpbml0KGN0eCk7XG5cdFx0fVxuXG5cdFx0Y3R4Ll9zZWxlY3Quc3R5bGUgPSBzdHlsZTtcblxuXHRcdC8vIEFkZCAvIHJlbW92ZSBtb3VzZSBldmVudCBoYW5kbGVycy4gVGhleSBhcmVuJ3QgcmVxdWlyZWQgd2hlbiBvbmx5XG5cdFx0Ly8gQVBJIHNlbGVjdGlvbiBpcyBhdmFpbGFibGVcblx0XHR2YXIgZHQgPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICk7XG5cdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKCBkdCApO1xuXHRcdFxuXHRcdGlmICggc3R5bGUgIT09ICdhcGknICkge1xuXHRcdFx0ZW5hYmxlTW91c2VTZWxlY3Rpb24oIGR0ICk7XG5cdFx0fVxuXG5cdFx0ZXZlbnRUcmlnZ2VyKCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICksICdzZWxlY3RTdHlsZScsIFsgc3R5bGUgXSApO1xuXHR9ICk7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LnNlbGVjdG9yKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnNlbGVjdG9yO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGRpc2FibGVNb3VzZVNlbGVjdGlvbiggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApICk7XG5cblx0XHRjdHguX3NlbGVjdC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0aWYgKCBjdHguX3NlbGVjdC5zdHlsZSAhPT0gJ2FwaScgKSB7XG5cdFx0XHRlbmFibGVNb3VzZVNlbGVjdGlvbiggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApICk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuXG5hcGlSZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5zZWxlY3QoKScsICdyb3coKS5zZWxlY3QoKScsIGZ1bmN0aW9uICggc2VsZWN0ICkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHRpZiAoIHNlbGVjdCA9PT0gZmFsc2UgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVzZWxlY3QoKTtcblx0fVxuXG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIGN0eCwgaWR4ICkge1xuXHRcdGNsZWFyKCBjdHggKTtcblxuXHRcdGN0eC5hb0RhdGFbIGlkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdCQoIGN0eC5hb0RhdGFbIGlkeCBdLm5UciApLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnc2VsZWN0JywgWyAncm93JywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3JvdygpLnNlbGVjdGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0aWYgKFxuXHRcdGN0eCAmJlxuXHRcdHRoaXMubGVuZ3RoICYmXG5cdFx0Y3R4LmFvRGF0YVt0aGlzWzBdXSAmJlxuXHRcdGN0eC5hb0RhdGFbdGhpc1swXV0uX3NlbGVjdF9zZWxlY3RlZFxuXHQpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuc2VsZWN0KCknLCAnY29sdW1uKCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHRjdHguYW9Db2x1bW5zWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gdHJ1ZTtcblxuXHRcdHZhciBjb2x1bW4gPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkuY29sdW1uKCBpZHggKTtcblxuXHRcdCQoIGNvbHVtbi5oZWFkZXIoKSApLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHQkKCBjb2x1bW4uZm9vdGVyKCkgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cblx0XHRjb2x1bW4ubm9kZXMoKS50byQoKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ3NlbGVjdCcsIFsgJ2NvbHVtbicsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdjb2x1bW4oKS5zZWxlY3RlZCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdGlmIChcblx0XHRjdHggJiZcblx0XHR0aGlzLmxlbmd0aCAmJlxuXHRcdGN0eC5hb0NvbHVtbnNbdGhpc1swXV0gJiZcblx0XHRjdHguYW9Db2x1bW5zW3RoaXNbMF1dLl9zZWxlY3Rfc2VsZWN0ZWRcblx0KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59ICk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5zZWxlY3QoKScsICdjZWxsKCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggY3R4LCByb3dJZHgsIGNvbElkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHR2YXIgZGF0YSA9IGN0eC5hb0RhdGFbIHJvd0lkeCBdO1xuXG5cdFx0aWYgKCBkYXRhLl9zZWxlY3RlZF9jZWxscyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZGF0YS5fc2VsZWN0ZWRfY2VsbHMgPSBbXTtcblx0XHR9XG5cblx0XHRkYXRhLl9zZWxlY3RlZF9jZWxsc1sgY29sSWR4IF0gPSB0cnVlO1xuXG5cdFx0aWYgKCBkYXRhLmFuQ2VsbHMgKSB7XG5cdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNvbElkeCBdICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnc2VsZWN0JywgWyAnY2VsbCcsIGFwaS5jZWxscyhhcGlbaV0pLmluZGV4ZXMoKS50b0FycmF5KCkgXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnY2VsbCgpLnNlbGVjdGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0aWYgKGN0eCAmJiB0aGlzLmxlbmd0aCkge1xuXHRcdHZhciByb3cgPSBjdHguYW9EYXRhW3RoaXNbMF1bMF0ucm93XTtcblxuXHRcdGlmIChyb3cgJiYgcm93Ll9zZWxlY3RlZF9jZWxscyAmJiByb3cuX3NlbGVjdGVkX2NlbGxzW3RoaXNbMF1bMF0uY29sdW1uXSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSApO1xuXG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCAncm93cygpLmRlc2VsZWN0KCknLCAncm93KCkuZGVzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0dGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggY3R4LCBpZHggKSB7XG5cdFx0Y3R4LmFvRGF0YVsgaWR4IF0uX3NlbGVjdF9zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsID0gbnVsbDtcblx0XHQkKCBjdHguYW9EYXRhWyBpZHggXS5uVHIgKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ2Rlc2VsZWN0JywgWyAncm93JywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5hcGlSZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kZXNlbGVjdCgpJywgJ2NvbHVtbigpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIGN0eCwgaWR4ICkge1xuXHRcdGN0eC5hb0NvbHVtbnNbIGlkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRcdHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICk7XG5cdFx0dmFyIGNvbHVtbiA9IGFwaS5jb2x1bW4oIGlkeCApO1xuXG5cdFx0JCggY29sdW1uLmhlYWRlcigpICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdCQoIGNvbHVtbi5mb290ZXIoKSApLnJlbW92ZUNsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblxuXHRcdC8vIE5lZWQgdG8gbG9vcCBvdmVyIGVhY2ggY2VsbCwgcmF0aGVyIHRoYW4ganVzdCB1c2luZ1xuXHRcdC8vIGBjb2x1bW4oKS5ub2RlcygpYCBhcyBjZWxscyB3aGljaCBhcmUgaW5kaXZpZHVhbGx5IHNlbGVjdGVkIHNob3VsZFxuXHRcdC8vIG5vdCBoYXZlIHRoZSBgc2VsZWN0ZWRgIGNsYXNzIHJlbW92ZWQgZnJvbSB0aGVtXG5cdFx0YXBpLmNlbGxzKCBudWxsLCBpZHggKS5pbmRleGVzKCkuZWFjaCggZnVuY3Rpb24gKGNlbGxJZHgpIHtcblx0XHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVsgY2VsbElkeC5yb3cgXTtcblx0XHRcdHZhciBjZWxsU2VsZWN0ZWQgPSBkYXRhLl9zZWxlY3RlZF9jZWxscztcblxuXHRcdFx0aWYgKCBkYXRhLmFuQ2VsbHMgJiYgKCEgY2VsbFNlbGVjdGVkIHx8ICEgY2VsbFNlbGVjdGVkWyBjZWxsSWR4LmNvbHVtbiBdKSApIHtcblx0XHRcdFx0JCggZGF0YS5hbkNlbGxzWyBjZWxsSWR4LmNvbHVtbiAgXSApLnJlbW92ZUNsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ2Rlc2VsZWN0JywgWyAnY29sdW1uJywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5hcGlSZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuZGVzZWxlY3QoKScsICdjZWxsKCkuZGVzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0dGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIGN0eCwgcm93SWR4LCBjb2xJZHggKSB7XG5cdFx0dmFyIGRhdGEgPSBjdHguYW9EYXRhWyByb3dJZHggXTtcblxuXHRcdGlmKGRhdGEuX3NlbGVjdGVkX2NlbGxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEuX3NlbGVjdGVkX2NlbGxzWyBjb2xJZHggXSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBjbGFzcyBvbmx5IGlmIHRoZSBjZWxscyBleGlzdCwgYW5kIHRoZSBjZWxsIGlzIG5vdCBjb2x1bW5cblx0XHQvLyBzZWxlY3RlZCwgaW4gd2hpY2ggY2FzZSB0aGUgY2xhc3Mgc2hvdWxkIHJlbWFpbiAoc2luY2UgaXQgaXMgc2VsZWN0ZWRcblx0XHQvLyBpbiB0aGUgY29sdW1uKVxuXHRcdGlmICggZGF0YS5hbkNlbGxzICYmICEgY3R4LmFvQ29sdW1uc1sgY29sSWR4IF0uX3NlbGVjdF9zZWxlY3RlZCApIHtcblx0XHRcdCQoIGRhdGEuYW5DZWxsc1sgY29sSWR4IF0gKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdkZXNlbGVjdCcsIFsgJ2NlbGwnLCBhcGlbaV0gXSwgdHJ1ZSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogQnV0dG9uc1xuICovXG5mdW5jdGlvbiBpMThuKCBsYWJlbCwgZGVmICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGR0KSB7XG5cdFx0cmV0dXJuIGR0LmkxOG4oICdidXR0b25zLicrbGFiZWwsIGRlZiApO1xuXHR9O1xufVxuXG4vLyBDb21tb24gZXZlbnRzIHdpdGggc3VpdGFibGUgbmFtZXNwYWNlc1xuZnVuY3Rpb24gbmFtZXNwYWNlZEV2ZW50cyAoIGNvbmZpZyApIHtcblx0dmFyIHVuaXF1ZSA9IGNvbmZpZy5fZXZlbnROYW1lc3BhY2U7XG5cblx0cmV0dXJuICdkcmF3LmR0LkRUJyt1bmlxdWUrJyBzZWxlY3QuZHQuRFQnK3VuaXF1ZSsnIGRlc2VsZWN0LmR0LkRUJyt1bmlxdWU7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZWQgKCBkdCwgY29uZmlnICkge1xuXHRpZiAoICQuaW5BcnJheSggJ3Jvd3MnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggJC5pbkFycmF5KCAnY29sdW1ucycsIGNvbmZpZy5saW1pdFRvICkgIT09IC0xICYmIGR0LmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCAkLmluQXJyYXkoICdjZWxscycsIGNvbmZpZy5saW1pdFRvICkgIT09IC0xICYmIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9idXR0b25OYW1lc3BhY2UgPSAwO1xuXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5idXR0b25zLCB7XG5cdHNlbGVjdGVkOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdGVkJywgJ1NlbGVjdGVkJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0ZWQnLFxuXHRcdGxpbWl0VG86IFsgJ3Jvd3MnLCAnY29sdW1ucycsICdjZWxscycgXSxcblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRjb25maWcuX2V2ZW50TmFtZXNwYWNlID0gJy5zZWxlY3QnKyhfYnV0dG9uTmFtZXNwYWNlKyspO1xuXG5cdFx0XHQvLyAuRFQgbmFtZXNwYWNlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBieSBEYXRhVGFibGVzIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIG9uIHRhYmxlIGRlc3Ryb3lcblx0XHRcdGR0Lm9uKCBuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5lbmFibGUoIGVuYWJsZWQoZHQsIGNvbmZpZykgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH0sXG5cdHNlbGVjdGVkU2luZ2xlOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdGVkU2luZ2xlJywgJ1NlbGVjdGVkIHNpbmdsZScgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdGVkLXNpbmdsZScsXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0ZHQub24oIG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSBkdC5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0ICAgICAgICAgICAgZHQuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBjb3VudCA9PT0gMSApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmZpZyApIHtcblx0XHRcdGR0Lm9mZiggY29uZmlnLl9ldmVudE5hbWVzcGFjZSApO1xuXHRcdH1cblx0fSxcblx0c2VsZWN0QWxsOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdEFsbCcsICdTZWxlY3QgYWxsJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LWFsbCcsXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLnNlbGVjdC5pdGVtcygpO1xuXHRcdFx0dGhpc1sgaXRlbXMrJ3MnIF0oKS5zZWxlY3QoKTtcblx0XHR9XG5cdH0sXG5cdHNlbGVjdE5vbmU6IHtcblx0XHR0ZXh0OiBpMThuKCAnc2VsZWN0Tm9uZScsICdEZXNlbGVjdCBhbGwnICksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3Qtbm9uZScsXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjbGVhciggdGhpcy5zZXR0aW5ncygpWzBdLCB0cnVlICk7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRjb25maWcuX2V2ZW50TmFtZXNwYWNlID0gJy5zZWxlY3QnKyhfYnV0dG9uTmFtZXNwYWNlKyspO1xuXG5cdFx0XHRkdC5vbiggbmFtZXNwYWNlZEV2ZW50cyhjb25maWcpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBjb3VudCA9IGR0LnJvd3MoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGggK1xuXHRcdFx0XHQgICAgICAgICAgICBkdC5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0ICAgICAgICAgICAgZHQuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cblx0XHRcdFx0dGhhdC5lbmFibGUoIGNvdW50ID4gMCApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmZpZyApIHtcblx0XHRcdGR0Lm9mZiggY29uZmlnLl9ldmVudE5hbWVzcGFjZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG4kLmVhY2goIFsgJ1JvdycsICdDb2x1bW4nLCAnQ2VsbCcgXSwgZnVuY3Rpb24gKCBpLCBpdGVtICkge1xuXHR2YXIgbGMgPSBpdGVtLnRvTG93ZXJDYXNlKCk7XG5cblx0RGF0YVRhYmxlLmV4dC5idXR0b25zWyAnc2VsZWN0JytpdGVtKydzJyBdID0ge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3QnK2l0ZW0rJ3MnLCAnU2VsZWN0ICcrbGMrJ3MnICksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3QtJytsYysncycsXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnNlbGVjdC5pdGVtcyggbGMgKTtcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQgKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRcdGR0Lm9uKCAnc2VsZWN0SXRlbXMuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgaXRlbXMgKSB7XG5cdFx0XHRcdHRoYXQuYWN0aXZlKCBpdGVtcyA9PT0gbGMgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG59ICk7XG5cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogSW5pdGlhbGlzYXRpb25cbiAqL1xuXG4vLyBEYXRhVGFibGVzIGNyZWF0aW9uIC0gY2hlY2sgaWYgc2VsZWN0IGhhcyBiZWVuIGRlZmluZWQgaW4gdGhlIG9wdGlvbnMuIE5vdGVcbi8vIHRoaXMgcmVxdWlyZWQgdGhhdCB0aGUgdGFibGUgYmUgaW4gdGhlIGRvY3VtZW50ISBJZiBpdCBpc24ndCB0aGVuIHNvbWV0aGluZ1xuLy8gbmVlZHMgdG8gdHJpZ2dlciB0aGlzIG1ldGhvZCB1bmZvcnR1bmF0ZWx5LiBUaGUgbmV4dCBtYWpvciByZWxlYXNlIG9mXG4vLyBEYXRhVGFibGVzIHdpbGwgcmV3b3JrIHRoZSBldmVudHMgYW5kIGFkZHJlc3MgdGhpcy5cbiQoZG9jdW1lbnQpLm9uKCAncHJlSW5pdC5kdC5kdFNlbGVjdCcsIGZ1bmN0aW9uIChlLCBjdHgpIHtcblx0aWYgKCBlLm5hbWVzcGFjZSAhPT0gJ2R0JyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHREYXRhVGFibGUuc2VsZWN0LmluaXQoIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSApO1xufSApO1xuXG5cbnJldHVybiBEYXRhVGFibGUuc2VsZWN0O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-select-bs5/node_modules/datatables.net-select/js/dataTables.select.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"$.fn.dataTable\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCIkLmZuLmRhdGFUYWJsZVwiPzgyMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSwyQ0FBMkMsRUFBRSIsImZpbGUiOiJkYXRhdGFibGVzLm5ldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCIkLmZuLmRhdGFUYWJsZVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///datatables.net\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"jQuery\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUNBQW1DLEVBQUUiLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImpRdWVyeVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///jquery\n");

/***/ })

/******/ })));